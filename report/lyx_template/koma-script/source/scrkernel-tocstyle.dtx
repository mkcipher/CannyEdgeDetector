% \CheckSum{1353}
% \iffalse meta-comment
% ======================================================================
% scrkernel-tocstyle.dtx
% Copyright (c) Markus Kohm, 2015-2017
%
% This file is part of the LaTeX2e KOMA-Script bundle.
%
% This work may be distributed and/or modified under the conditions of
% the LaTeX Project Public License, version 1.3c of the license.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
% and version 1.3c or later is part of all distributions of LaTeX 
% version 2005/12/01 or later and of this work.
%
% This work has the LPPL maintenance status "author-maintained".
%
% The Current Maintainer and author of this work is Markus Kohm.
%
% This work consists of all files listed in manifest.txt.
% ----------------------------------------------------------------------
% scrkernel-tocstyle.dtx
% Copyright (c) Markus Kohm, 2015-2017
%
% Dieses Werk darf nach den Bedingungen der LaTeX Project Public Lizenz,
% Version 1.3c, verteilt und/oder veraendert werden.
% Die neuste Version dieser Lizenz ist
%   http://www.latex-project.org/lppl.txt
% und Version 1.3c ist Teil aller Verteilungen von LaTeX
% Version 2005/12/01 oder spaeter und dieses Werks.
%
% Dieses Werk hat den LPPL-Verwaltungs-Status "author-maintained"
% (allein durch den Autor verwaltet).
%
% Der Aktuelle Verwalter und Autor dieses Werkes ist Markus Kohm.
% 
% Dieses Werk besteht aus den in manifest.txt aufgefuehrten Dateien.
% ======================================================================
% \fi
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
% \iffalse
%%% From File: $Id: scrkernel-tocstyle.dtx 2731 2017-11-23 09:04:09Z kohm $
% The runs of run-time file generation:
%<preidentify>%%%            (run: preidentify)
% - everything that is needed before selfidentification of resulting files
%   (unused)
%<identify>%%%            (run: identify)
% - everything that is needed for selfidentification of resulting files
%   (unused)
%<prepare>%%%            (run: prepare)
% - everything that is needed to define options
%<option>%%%            (run: option)
% - definition of options (unused)
%<execoption>%%%            (run: execoption)
% - initial option executions up to \KOMAProcessOptions 
%   (unused)
%<body>%%%            (run: body)
% - everything, that should be done after \KOMAProcessOptions
%<exit>%%%            (run: exit)
% - everything, that should be done immediately before leaving the file
%   (unused) 
%<*dtx>
% \fi
\ifx\ProvidesFile\undefined\def\ProvidesFile#1[#2]{}\fi
\begingroup
  \def\filedate$#1: #2-#3-#4 #5${\gdef\filedate{#2/#3/#4}}
  \filedate$Date: 2017-11-23 10:04:09 +0100 (Thu, 23 Nov 2017) $
  \def\filerevision$#1: #2 ${\gdef\filerevision{r#2}}
  \filerevision$Revision: 2254 $
  \edef\reserved@a{%
    \noexpand\endgroup
    \noexpand\ProvidesFile{scrkernel-tocstyle.dtx}%
                          [\filedate\space\filerevision\space
                           KOMA-Script source (TOC styles)]
  }%
\reserved@a
% \iffalse
\documentclass[parskip=half-]{scrdoc}
\usepackage[english,ngerman]{babel}
\usepackage[latin1]{inputenc}
\CodelineIndex
\RecordChanges
\GetFileInfo{scrkernel-tocstyle.dtx}
\title{\KOMAScript{} \partname\ \texttt{\filename}%
  \footnote{Dies ist Version \fileversion\ von Datei
    \texttt{\filename}.}}
\date{\filedate}
\author{Markus Kohm}

\begin{document}
  \maketitle
  \tableofcontents
  \DocInput{\filename}
\end{document}
%</dtx>
% \fi
%
% \selectlanguage{ngerman}
%
% \section{Verzeichnisstile}
%
% Verzeichnisstile werden derzeit nur in Kooperation mit Gliederungsstilen
% untersützt. In Zukunft soll das aber mal anders werden. Dann sollen
% Verzeichnisstile Teil der Grundfunktionalität für Verzeichnisse (Paket
% \textsf{tocbasic}) werden und auch unabhängig von Gliederungsstilen
% einsetzbar sein.
%
% \StopEventually{\PrintIndex\PrintChanges}
%
% \changes{v3.20}{2015/11/13}{neu und nur bei Vorhandensein verwendet}
%
%
% \subsection{Einstellungen unabhängig von Verzeichnisstilen und doch
%   Grundlage für diese}
%
% Bis \KOMAScript~3.20 waren die Befehle, die hier definiert werden, Teil der
% KOMA-Script-Klassen. Allerdings zeigt sich, dass es für die Definition von
% Verzeichnisstilen von Vorteil ist, wenn diese Definitionen im Paket
% vorhanden sind.
%
% \iffalse
%<*package>
% \fi
%
% \begin{macro}{\numberline}
%   \changes{v3.20}{2016/03/10}{\cs{numberline} wird indirekt über
%     \cs{scr@numberline} definiert}^^A
% \begin{macro}{\scr@numberline}
%   \changes{v2.3c}{1995/08/06}{\cs{numberline} umdefiniert}^^A
%   \changes{v3.06}{2010/05/18}{Verwendung von \cs{numberline@prefix} und
%     \cs{numberline@postfix}}^^A
%   \changes{v3.12}{2013/11/22}{use \cs{numberline@numberformat} only, if the
%     argument expands to a non-empty string}^^A
% Dieses Makro wird indirekt im Inhaltsverzeichnis verwendet und muss
% umdefiniert werden, um Duden, 20.~Auflage, Regel~5 und Regel~6 zu
% implementieren.
%    \begin{macrocode}
%<*body>
\newcommand*{\scr@numberline}[1]{%
  \numberline@box{%
    \numberline@prefix
    \ifstr{#1}{}{#1}{%
      \numberline@numberformat{#1}%
    }%
    \numberline@postfix
  }%
}
%    \end{macrocode}
% \begin{macro}{\usetocbasicnumberline}
%   \changes{v3.20}{2016/03/15}{neu}^^A
% Dieses Makro testet, ob \cs{numberline} auf \cs{scr@numberline}
% basiert. Falls das nicht der Fall ist, führt es das optionale Argument aus
% und führt dann eine entsprechende Umdefinierung statt. Falls es jedoch der
% Fall ist, lässt es alles unverändert.
%    \begin{macrocode}
\newcommand*{\usetocbasicnumberline}[1][%
  \PackageInfo{tocbasic}{Using my definition of `\string\numberline'}%
]{%
  \@tempswatrue
  \begingroup
    \def\scr@numberline##1{\global\@tempswafalse}%
%    \end{macrocode}
% \cs{@tempdima} ist üblicherweise bei \cs{numberline} die Breite der Nummer.
% Damit zu kleine Werte nicht zu einem Problem werden können, nehme ich hier
% gleich mal einen richtig großen Wert.
%    \begin{macrocode}
    \@tempdima\maxdimen
    \sbox\@tempboxa{\numberline{0}}%
  \endgroup
  \if@tempswa #1\renewcommand*{\numberline}[1]{\scr@numberline{##1}}\fi
}
%    \end{macrocode}
% \end{macro}^^A \usetocbasicnumberline
% \begin{macro}{\numberline@prefix}
%   \changes{v3.06}{2010/05/18}{neu (intern)}^^A
% Das ist in der Voreinstellung einfach leer. Es könnte verwendet werden, um
% etwas vor die Nummer zu setzen oder die Nummer rechtsbündig zu setzen.
%    \begin{macrocode}
\newcommand*{\numberline@prefix}{}
%    \end{macrocode}
% \end{macro}^^A \numberline@prefix
% \begin{macro}{\numberline@postfix}
%   \changes{v3.06}{2010/05/18}{neu (intern)} 
% Das ist in der Voreinstellung einfach \cs{hfil} und dient dazu die Nummer
% linksbündig zu platzieren.
%    \begin{macrocode}
\newcommand*{\numberline@postfix}{\hfil}
%    \end{macrocode}
% \end{macro}^^A \numberline@postfix
% \begin{macro}{\numberline@numberformat}
%   \changes{v3.06}{2010/05/18}{neu (intern)}^^A
%   \changes{v3.12}{2013/11/22}{don't output anything, if argument expands to
%     an empty string}^^A
% Das dient in der Voreinstellung dazu, Regel~5 und 6 aus der 20.~Auflage des
% DUDENs umzusetzen.
%    \begin{macrocode}
\newcommand*{\numberline@numberformat}[1]{%
  \ifstr{#1}{}{}{\numberline@numberprefix#1\numberline@numberpostfix}%
}
%    \end{macrocode}
% \begin{macro}{\numberline@numberprefix}
%   \changes{v3.20}{2016/03/15}{neu (intern)}
% Wird verwendet, um innerhalb von \cs{numberline@numberformat} der Nummer
% einen Präfix voran zu stellen. Im Gegensatz zu \cs{numberline@prefix} wird
% dieser nur ausgegeben, wenn das Argument von \cs{numberline@numberformat},
% also auch das Argument von \cs{numberline} nicht leer ist.
%    \begin{macrocode}
\newcommand*{\numberline@numberprefix}{}
%    \end{macrocode}
% \end{macro}^^A \numberline@numberprefix
% \begin{macro}{\numberline@numberpostfix}
%   \changes{v3.20}{2016/03/15}{neu (intern)}
% Wird verwendet, um innerhalb von \cs{numberline@numberformat} der Nummer
% einen Postfix anzuhängen. Im Gegensatz zu \cs{numberline@prefix} wird
% dieser nur ausgegeben, wenn das Argument von \cs{numberline@numberformat},
% also auch das Argument von \cs{numberline} nicht leer ist.
%    \begin{macrocode}
\newcommand*{\numberline@numberpostfix}{}
%    \end{macrocode}
% \end{macro}^^A \numberline@numberpostfix
% \end{macro}^^A \numberline@numberformat
% \begin{macro}{\numberline@box}
%   \changes{v3.06}{2010/05/18}{neu (intern)} 
% Das dient in der Voreinstellung dazu, die Gliederungsnummer in eine Box zu
% setzen.
%    \begin{macrocode}
\newcommand*{\numberline@box}[1]{\hb@xt@\@tempdima{#1}}
%</body>
%    \end{macrocode}
% \end{macro}^^A \numberline@box
% \end{macro}^^A \scr@numberline
%
% \iffalse
%</package>
%<*class>
% \fi
%
%    \begin{macrocode}
%<*body>
\let\numberline\scr@numberline
%</body>
%    \end{macrocode}
% \end{macro}^^A \numberline
%
% \iffalse
%</class>
% \fi
%
% \subsection{Grundlagen für Verzeichniseintragsstile}
%
% Ab \KOMAScript~3.20 halten Stile Einzug in die Verzeichnisse. Der erste
% Schritt dabei sind die Stile der Verzeichniseinträge. Jeder Stil besteht aus
% einer Anweisung, mit der ein Verzeichnisbefehl definiert wird und
% zugehörigen Optionen. Die Optionen dienen dazu, Einstellungen für die
% einzelnen Verzeichnisbefehle vorzunehmen.
%
% \iffalse
%<*package>
% \fi
%
% \changes{v3.20}{2015/11/17}{Verzeichnisstile bekommen das
%   \texttt{KOMAarg}-Mitglied \texttt{.dte}}^^A
%    \begin{macrocode}
%<*body>
\DefineFamily{KOMAarg}
\DefineFamilyMember[.dte]{KOMAarg}
%</body>
%    \end{macrocode}
%
% \begin{macro}{\@DefineTOCEntryOption}
%   \changes{v3.20}{2015/04/10}{neu (intern)}
% Die Definition der Optionen geschieht mit einer einheitlichen
% Schnittstelle. Wichtig dabei ist, dass hier nicht tatsächlich die Optionen
% definiert werden, sondern eine Anweisung, die ihrerseits die Optionen bei
% Bedarf definiert. Ein solcher Bedarf besteht beispielsweise bei der
% Definition des Eintragsbefehls selbst. Er besteht aber auch innerhalb von
% \cs{DeclareSectionCommand}, weil diese Anweisung ebenfalls indirekt
% Verzeichniseinträge definiert und deshalb die Optionen auswerten können
% soll. Es gibt folgende Parameter:
% \begin{description}
% \item[\marg{Stil}: \meta{String},] Name des Eintragsstils
% \item[\marg{Option}: \meta{String},] Name der Option
% \item[\oarg{Wert}:] der Säumniswert der Option abhängig von der
%   \meta{Definition}
% \item[\marg{Definition}: \meta{Code},] Definition der Option
% \end{description}
% \begin{macro}{\@DefineTOCEntryOptionWithoutDefault}
%   \changes{v3.20}{2015/11/10}{neu (intern)}
% \begin{macro}{\@DefineTOCEntryOptionWithDefault}
%   \changes{v3.20}{2015/11/10}{neu (intern)}
% Da mit einem optionalen Argument an Position 3 gearbeitet wird, werden zwei
% Hilfsmakros benötigt.
%    \begin{macrocode}
%<*body>
\newcommand*{\@DefineTOCEntryOption}[2]{%
  \edef\scr@dte@doopts{%
    \unexpanded\expandafter{\scr@dte@doopts}\noexpand\do{#2}%
  }%
  \kernel@ifnextchar [%]
    {\@DefineTOCEntryOptionWithDefault{#1}{#2}}%
    {\@DefineTOCEntryOptionWithoutDefault{#1}{#2}}%
}
\newcommand*{\@DefineTOCEntryOptionWithoutDefault}[3]{%
  \DefineFamilyKey[.dte]{KOMAarg}{#2}{#3}%
}
\newcommand*{\@DefineTOCEntryOptionWithDefault}{}
\def\@DefineTOCEntryOptionWithDefault#1#2[#3]#4{%
  \l@addto@macro\scr@dte@doopts{[{#3}]}%
  \DefineFamilyKey[.dte]{KOMAarg}{#2}[{#3}]{#4}%
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \@DefineTOCEntryOptionWithoutDefault
% \end{macro}^^A \@DefineTOCEntryOptionWithDefault
% \end{macro}^^A \@DefineTOCEntryOption
%
% \begin{macro}{\@RelaxTOCEntryOptions}
%   \changes{v3.20}{2015/04/10}{neu (intern)}
% Setzt alle Optionen der aktuellen Do-Liste zurück auf \cs{relax}.
%    \begin{macrocode}
%<*body>
\newcommand*{\@RelaxTOCEntryOptions}{%
  \begingroup
    \def\do@endgroup{\endgroup}%
    \def\do##1{%
      \l@addto@macro\do@endgroup{\RelaxFamilyKey[.dte]{KOMAarg}{##1}}%
      \scr@dte@gobbleopt
    }%
    \scr@dte@doopts
  \do@endgroup
}
\newcommand{\scr@dte@gobbleopt}[1][]{}
%</body>
%    \end{macrocode}
% \end{macro}^^A \@RelaxTOCEntryOptions
%
% \begin{macro}{\@DefineTOCEntryLengthOption}
%   \changes{v3.20}{2015/12/04}{neu (intern)}
% Verwendet \cs{DefineTOCEntryOption}, um eine Option zu definieren, die ein
% Längenmacro definiert. Es gibt folgende Parameter:
% \begin{description}
% \item[\marg{Stil}: \meta{String},] Name des Eintragsstils
% \item[\marg{Option}: \meta{String},] Name der Option
% \item[\oarg{Wert}:] der Säumniswert der Option
% \item[\marg{Prefix}: \meta{String},] Präfix des zu definierenden Makros
% \item[\marg{Postfix}: \meta{String},] Postfix des zu definierenden Makros
% \item[\marg{Erklärung}: \meta{String},] Erklärung der Option
% \item[\oarg{Init}: \meta{Code},] Initialisierung der Option
% \end{description}
% Zwischen Prefix und Postfix wird bei der späteren, tatsächlichen Definition
% automatisch \cs{scr@dte@current} eingefügt.
% \begin{macro}{\@DefineTOCEntryLengthOptionWithoutDefault}
%   \changes{v3.20}{2015/11/10}{neu (intern)}^^A
% \begin{macro}{\@DefineTOCEntryLengthOptionWithDefault}
%   \changes{v3.20}{2015/11/10}{neu (intern)}^^A
% \begin{macro}{\@DefineTOCEntryLengthOptionMacro}
%   \changes{v3.20}{2015/11/10}{neu (intern)}^^A
% Da mit einem optionalen Argument an Position 3 gearbeitet wird, werden drei
% Hilfsmakros benötigt.
%    \begin{macrocode}
%<*body>
\newcommand*{\@DefineTOCEntryLengthOption}[2]{%
  \kernel@ifnextchar [%]
    {\@DefineTOCEntryLengthOptionWithDefault{#1}{#2}}
    {\@DefineTOCEntryLengthOptionWithoutDefault{#1}{#2}}%
}
\newcommand*{\@DefineTOCEntryLengthOptionWithoutDefault}[5]{%
  \@TOCEntryStyleNeedsCommandByOption{#1}{#3}{#4}{#2}{#5}%
  \@DefineTOCEntryOption{#1}{#2}{%
    \@DefineTOCEntryLengthOptionMacro{#2}{#3}{#4}{##1}%
  }%
}
\newcommand*{\@DefineTOCEntryLengthOptionWithDefault}{}
\def\@DefineTOCEntryLengthOptionWithDefault#1#2[#3]#4#5#6{%
  \@TOCEntryStyleNeedsCommandByOption{#1}{#4}{#5}{#2}{#6}%
  \@DefineTOCEntryOption{#1}{#2}[{#3}]{%
    \@DefineTOCEntryLengthOptionMacro{#2}{#4}{#5}{##1}%
  }%
}
\newcommand*{\@DefineTOCEntryLengthOptionMacro}[4]{%
  \protected@edef\reserved@a{%
    \noexpand\FamilySetLength{KOMAarg}{#1}{\noexpand\@tempskipa}{#4}%
  }\reserved@a
  \ifx\FamilyKeyState\FamilyKeyStateProcessed
    \ifscr@dte@expandtopt
      \expandafter\edef\csname #2\scr@dte@current#3\endcsname{%
        \the\@tempskipa}%
    \else
      \expandafter\protected@edef\csname #2\scr@dte@current#3\endcsname{#4}%
    \fi
  \fi
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \@DefineTOCEntryLengthOptionMacro
% \end{macro}^^A \@DefineTOCEntryLengthOptionWithDefault
% \end{macro}^^A \@DefineTOCEntryLengthOptionWithoutDefault
% \end{macro}^^A \@DefineTOCEntryLengthOption
%
% \begin{macro}{\@DefineTOCEntryNumberOption}
%   \changes{v3.20}{2015/12/04}{neu (intern)}
% Verwendet \cs{DefineTOCEntryOption}, um eine Option zu definieren, die ein
% Nummernmacro definiert. Es gibt folgende Parameter:
% \begin{description}
% \item[\marg{Stil}: \meta{String},] Name des Eintragsstils
% \item[\marg{Option}: \meta{String},] Name der Option
% \item[\oarg{Wert}:] der Säumniswert der Option
% \item[\marg{Prefix}: \meta{String},] Präfix des zu definierenden Makros
% \item[\marg{Postfix}: \meta{String},] Postfix des zu definierenden Makros
% \item[\marg{Erklärung}: \meta{String},] Erklärung der Option
% \item[\oarg{Init}: \meta{Code},] Initialisierung der Option
% \end{description}
% Zwischen Prefix und Postfix wird bei der späteren, tatsächlichen Definition
% automatisch \cs{scr@dte@current} eingefügt.
% \begin{macro}{\@DefineTOCEntryNumberOptionWithoutDefault}
%   \changes{v3.20}{2015/11/12}{neu (intern)}
% \begin{macro}{\@DefineTOCEntryNumberOptionWithDefault}
%   \changes{v3.20}{2015/11/12}{neu (intern)}
% \begin{macro}{\@DefineTOCEntryNumberOptionMacro}
%   \changes{v3.20}{2015/11/12}{neu (intern)}
% Da mit einem optionalen Argument an Position 3 gearbeitet wird, werden drei
% Hilfsmakros benötigt.
%    \begin{macrocode}
%<*body>
\newcommand*{\@DefineTOCEntryNumberOption}[2]{%
  \kernel@ifnextchar [%]
    {\@DefineTOCEntryNumberOptionWithDefault{#1}{#2}}
    {\@DefineTOCEntryNumberOptionWithoutDefault{#1}{#2}}%
}
\newcommand*{\@DefineTOCEntryNumberOptionWithoutDefault}[5]{%
  \@TOCEntryStyleNeedsCommandByOption{#1}{#3}{#4}{#2}{#5}%
  \@DefineTOCEntryOption{#1}{#2}{%
    \@DefineTOCEntryNumberOptionMacro{#2}{#3}{#4}{##1}%
  }%
}
\newcommand*{\@DefineTOCEntryNumberOptionWithDefault}{}
\def\@DefineTOCEntryNumberOptionWithDefault#1#2[#3]#4#5#6{%
  \@TOCEntryStyleNeedsCommandByOption{#1}{#4}{#5}{#2}{#6}%
  \@DefineTOCEntryOption{#1}{#2}[{#3}]{%
    \@DefineTOCEntryNumberOptionMacro{#2}{#4}{#5}{##1}%
  }%
}
\newcommand*{\@DefineTOCEntryNumberOptionMacro}[4]{%
  \protected@edef\reserved@a{%
    \noexpand\FamilySetCounterMacro{KOMAarg}{#1}{%
      \expandafter\noexpand\csname #2\scr@dte@current#3\endcsname
    }{#4}%
  }\reserved@a
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \@DefineTOCEntryNumberOptionMacro
% \end{macro}^^A \@DefineTOCEntryNumberOptionWithDefault
% \end{macro}^^A \@DefineTOCEntryNumberOptionWithoutDefault
% \end{macro}^^A \@DefineTOCEntryNumberOption
%
% \begin{macro}{\@DefineTOCEntryBooleanOption}
%   \changes{v3.20}{2015/12/04}{neu (intern)}
% Verwendet \cs{DefineTOCEntryOption}, um eine Option zu definieren, die einen
% Schalter definiert. Es gibt folgende Parameter:
% \begin{description}
% \item[\marg{Stil}: \meta{String},] Name des Eintragsstils
% \item[\marg{Option}: \meta{String},] Name der Option
% \item[\oarg{Wert}:] der Säumniswert der Option
% \item[\marg{Prefix}: \meta{String},] Präfix des zu definierenden Makros
% \item[\marg{Postfix}: \meta{String},] Postfix des zu definierenden Makros
% \item[\marg{Erklärung}: \meta{String},] Erklärung der Option
% \item[\oarg{Init}: \meta{Code},] Initialisierung der Option
% \end{description}
% Zwischen Prefix und Postfix wird bei der späteren, tatsächlichen Definition
% automatisch \cs{scr@dte@current} eingefügt.
% \begin{macro}{\@DefineTOCEntryBoolOptionWithoutDefault}
%   \changes{v3.20}{2015/11/12}{neu (intern)}
% \begin{macro}{\@DefineTOCEntryBoolOptionWithDefault}
%   \changes{v3.20}{2015/11/12}{neu (intern)}
% \begin{macro}{\@DefineTOCEntryBoolOptionMacro}
%   \changes{v3.20}{2015/11/12}{neu (intern)}
% Da mit einem optionalen Argument an Position 3 gearbeitet wird, werden drei
% Hilfsmakros benötigt.
%    \begin{macrocode}
%<*body>
\newcommand*{\@DefineTOCEntryBooleanOption}[2]{%
  \kernel@ifnextchar [%]
    {\@DefineTOCEntryBoolOptionWithDefault{#1}{#2}}
    {\@DefineTOCEntryBoolOptionWithoutDefault{#1}{#2}}%
}
\newcommand*{\@DefineTOCEntryBoolOptionWithoutDefault}[5]{%
  \@TOCEntryStyleNeedsCommandByOption{#1}{if#3}{#4}{#2}{#5}%
  \@TOCEntryStyleNeedsCommandByOption{#1}{#3}{#4false}{#2}{#5}%
  \@TOCEntryStyleNeedsCommandByOption{#1}{#3}{#4false}{#2}{#5}%
  \@DefineTOCEntryOption{#1}{#2}[true]{%
    \@DefineTOCEntryBoolOptionMacro{#2}{#3}{#4}{##1}%
  }%
}
\newcommand*{\@DefineTOCEntryBoolOptionWithDefault}{}
\def\@DefineTOCEntryBoolOptionWithDefault#1#2[#3]#4#5#6{%
  \@TOCEntryStyleNeedsCommandByOption{#1}{if#4}{#5}{#2}{#6}%
  \@TOCEntryStyleNeedsCommandByOption{#1}{#4}{#5true}{#2}{#6}%
  \@TOCEntryStyleNeedsCommandByOption{#1}{#4}{#5false}{#2}{#6}%
  \@DefineTOCEntryOption{#1}{#2}[{#3}]{%
    \@DefineTOCEntryBoolOptionMacro{#2}{#4}{#5}{##1}%
  }%
}
\newcommand*{\@DefineTOCEntryBoolOptionMacro}[4]{%
  \@ifundefined{if#2\scr@dte@current#3}{%
    \expandafter\newif\csname if#2\scr@dte@current#3\endcsname
  }{}%
  \FamilySetBool{KOMAarg}{#1}{#2\scr@dte@current#3}{#4}%
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \@DefineTOCEntryBoolOptionMacro
% \end{macro}^^A \@DefineTOCEntryBoolOptionWithDefault
% \end{macro}^^A \@DefineTOCEntryBoolOptionWithoutDefault
% \end{macro}^^A \@DefineTOCEntryBooleanOption
%
% \begin{macro}{\@DefineTOCEntryIfOption}
%   \changes{v3.20}{2015/12/06}{neu (intern)}
% Verwendet \cs{DefineTOCEntryOption}, um eine Option zu definieren, die eine
% If-Anweisung definiert. Die Option selbst ist dabei eine Schalter-Option. Es
% gibt folgende Parameter:
% \begin{description}
% \item[\marg{Stil}: \meta{String},] Name des Eintragsstils
% \item[\marg{Option}: \meta{String},] Name der Option
% \item[\oarg{Wert}:] der Säumniswert der Option
% \item[\marg{Prefix}: \meta{String},] Präfix des zu definierenden Makros
% \item[\marg{Postfix}: \meta{String},] Postfix des zu definierenden Makros
% \item[\marg{Erklärung}: \meta{String},] Erklärung der Option
% \end{description}
% Zwischen Prefix und Postfix wird bei der späteren, tatsächlichen Definition
% automatisch \cs{scr@dte@current} eingefügt.
% \begin{macro}{\@DefineTOCEntryIfOptionWithoutDefault}
%   \changes{v3.20}{2015/11/12}{neu (intern)}
% \begin{macro}{\@DefineTOCEntryIfOptionWithDefault}
%   \changes{v3.20}{2015/11/12}{neu (intern)}
% \begin{macro}{\@DefineTOCEntryIfOptionMacro}
%   \changes{v3.20}{2015/11/12}{neu (intern)}
% Da mit einem optionalen Argument an Position 3 gearbeitet wird, werden drei
% Hilfsmakros benötigt.
%    \begin{macrocode}
%<*body>
\newcommand*{\@DefineTOCEntryIfOption}[2]{%
  \kernel@ifnextchar [%]
    {\@DefineTOCEntryIfOptionWithDefault{#1}{#2}}
    {\@DefineTOCEntryIfOptionWithoutDefault{#1}{#2}}%
}
\newcommand*{\@DefineTOCEntryIfOptionWithoutDefault}[5]{%
  \@TOCEntryStyleNeedsCommandByOption{#1}{If#3}{#4}{#2}{#5}%
  \@DefineTOCEntryOption{#1}{#2}[true]{%
    \@DefineTOCEntryIfOptionMacro{#2}{#3}{#4}{##1}%
  }%
}
\newcommand*{\@DefineTOCEntryIfOptionWithDefault}{}
\def\@DefineTOCEntryIfOptionWithDefault#1#2[#3]#4#5#6{%
  \@TOCEntryStyleNeedsCommandByOption{#1}{If#4}{#5}{#2}{#6}%
  \@DefineTOCEntryOption{#1}{#2}[{#3}]{%
    \@DefineTOCEntryIfOptionMacro{#2}{#4}{#5}{##1}%
  }%
}
\newcommand*{\@DefineTOCEntryIfOptionMacro}[4]{%
  \FamilySetBool{KOMAarg}{#1}{@tempswa}{#4}%
  \ifx\FamilyKeyState\FamilyKeyStateProcessed
    \if@tempswa
      \expandafter\let\csname If#2\scr@dte@current#3\endcsname\@firstoftwo
    \else
      \expandafter\let\csname If#2\scr@dte@current#3\endcsname\@secondoftwo
    \fi
  \fi
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \@DefineTOCEntryIfOptionMacro
% \end{macro}^^A \@DefineTOCEntryIfOptionWithDefault
% \end{macro}^^A \@DefineTOCEntryIfOptionWithoutDefault
% \end{macro}^^A \@DefineTOCEntryIfOption
%
% \begin{macro}{\@DefineTOCEntryCommandOption}
%   \changes{v3.20}{2015/11/17}{neu}
% Verwendet \cs{DefineTOCEntryOption}, um eine Option zu definieren, die ein
% Macro definiert. Es gibt folgende Parameter:
% \begin{description}
% \item[\marg{Stil}: \meta{String},] Name des Eintragsstils
% \item[\marg{Option}: \meta{String},] Name der Option
% \item[\oarg{Wert}:] der Säumniswert der Option
% \item[\marg{Prefix}: \meta{String},] Präfix des zu definierenden Makros
% \item[\marg{Postfix}: \meta{String},] Postfix des zu definierenden Makros
% \item[\oarg{Argumentzahl}: \meta{Nummer},] Anzahl der Argumente des Makros
% \item[\marg{Erklärung}: \meta{String},] Erklärung der Option
% \item[\oarg{Init}: \meta{Code},] Initialisierung der Option
% \end{description}
% Zwischen Prefix und Postfix wird bei der späteren, tatsächlichen Definition
% automatisch \cs{scr@dte@current} eingefügt.
% \begin{macro}{\@DefineTOCEntryCommandOptionWithoutDefault}
%   \changes{v3.20}{2015/11/12}{neu (intern)}
% \begin{macro}{\@@DefineTOCEntryCommandOptionWithoutDefault}
%   \changes{v3.20}{2015/11/26}{neu (intern)}
% \begin{macro}{\@DefineTOCEntryCommandOptionWithDefault}
%   \changes{v3.20}{2015/11/12}{neu (intern)}
% \begin{macro}{\@@DefineTOCEntryCommandOptionWithDefault}
%   \changes{v3.20}{2015/11/26}{neu (intern)}
% \begin{macro}{\@DefineTOCEntryCommandOptionMacro}
%   \changes{v3.20}{2015/11/12}{neu (intern)}
% \begin{macro}{\@@DefineTOCEntryCommandOptionMacro}
%   \changes{v3.20}{2015/11/26}{neu (intern)}
% Da mit einem optionalen Argument an Position 3 gearbeitet wird, werden drei
% Hilfsmakros benötigt.
%    \begin{macrocode}
%<*body>
\newcommand*{\@DefineTOCEntryCommandOption}[2]{%
  \kernel@ifnextchar [%]
    {\@DefineTOCEntryCommandOptionWithDefault{#1}{#2}}
    {\@DefineTOCEntryCommandOptionWithoutDefault{#1}{#2}}%
}
\newcommand*{\@DefineTOCEntryCommandOptionWithoutDefault}[4]{%
  \@testopt{\@@DefineTOCEntryCommandOptionWithoutDefault{#1}{#2}{#3}{#4}}0%
}
\newcommand*{\@@DefineTOCEntryCommandOptionWithoutDefault}{}%
\def\@@DefineTOCEntryCommandOptionWithoutDefault#1#2#3#4[#5]#6{%
  \@TOCEntryStyleNeedsCommandByOption{#1}{#3}{#4}{#2}{#6}%
  \ifcase #5
    \@DefineTOCEntryOption{#1}{#2}{%
      \@DefineTOCEntryCommandOptionMacro{#2}{#3}{#4}[#5]{##1}%
    }%
  \or
    \@DefineTOCEntryOption{#1}{#2}{%
      \@DefineTOCEntryCommandOptionMacro{#2}{#3}{#4}[#5]{##1{####1}}%
    }%
  \else
%<class>    \ClassError{\KOMAClassName
%<package>    \PackageError{tocbasic%
    }{only one argument supported}{%
      \string\DefineTOCEntryCommandOption\space currently supports only
      commands with\MessageBreak
      at most one argument not #5}%
  \fi
}
\newcommand*{\@DefineTOCEntryCommandOptionWithDefault}{}
\def\@DefineTOCEntryCommandOptionWithDefault#1#2[#3]#4#5{%
  \@testopt{\@@DefineTOCEntryCommandOptionWithDefault{#1}{#2}{#3}{#4}{#5}}0%
}
\def\@@DefineTOCEntryCommandOptionWithDefault#1#2#3#4#5[#6]#7{%
  \@TOCEntryStyleNeedsCommandByOption{#1}{#4}{#5}{#2}{#7}%
  \ifcase #6
    \@DefineTOCEntryOption{#1}{#2}[{#3}]{%
      \@DefineTOCEntryCommandOptionMacro{#2}{#4}{#5}[#6]{##1}%
    }%
  \or
    \@DefineTOCEntryOption{#1}{#2}[{#3}]{%
      \@DefineTOCEntryCommandOptionMacro{#2}{#4}{#5}[#6]{##1{####1}}%
    }%
  \or
    \@DefineTOCEntryOption{#1}{#2}[{#3}]{%
      \@DefineTOCEntryCommandOptionMacro{#2}{#4}{#5}[#6]{##1{####1}{####2}}%
    }%
  \else
%<class>    \ClassError{\KOMAClassName
%<package>    \PackageError{tocbasic%
    }{only one argument supported}{%
      \string\DefineTOCEntryCommandOption\space currently supports only
      commands with\MessageBreak
      at most two argument not #6}%
  \fi
}
\newcommand*{\@DefineTOCEntryCommandOptionMacro}[3]{%
  \@testopt{\@@DefineTOCEntryCommandOptionMacro{#1}{#2}{#3}}0%
}
\newcommand*{\@@DefineTOCEntryCommandOptionMacro}{}
\long\def\@@DefineTOCEntryCommandOptionMacro#1#2#3[#4]#5{%
  \let\l@ngrel@x\long
  \expandafter\@yargdef\csname #2\scr@dte@current#3\endcsname\@ne{#4}{#5}%
  \FamilyKeyStateProcessed
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \@@DefineTOCEntryCommandOptionMacro
% \end{macro}^^A \@DefineTOCEntryCommandOptionMacro
% \end{macro}^^A \@@DefineTOCEntryCommandOptionWithDefault
% \end{macro}^^A \@DefineTOCEntryCommandOptionWithDefault
% \end{macro}^^A \@@DefineTOCEntryCommandOptionWithoutDefault
% \end{macro}^^A \@DefineTOCEntryCommandOptionWithoutDefault
% \end{macro}^^A \@DefineTOCEntryCommandOption
%
% \begin{macro}{\@AddToDeclareTOCStyleEntryPreCheckNeeds}
%   \changes{v3.20}{2015/12/06}{neu (intern)}
% \begin{macro}{\@PreToDeclareTOCStyleEntryPreCheckNeeds}
%   \changes{v3.20}{2015/12/06}{neu (intern)}
% Noch bevor die benötigten Befehle getestet werden, wird in
% \cs{DeclareTOCStyleEntry} ein Hook ausgeführt. Für das Hinzufügen von Code
% zu diesem Hook gibt es folgende Parameter:
% \begin{description}
% \item[\marg{Code}: \meta{Code},] Code, der ausgeführt werden soll.
% \end{description}
% Bitte beachten, dass diese Anweisung im Init-Code von Stilen verwendet wird,
% also innerhalb von \cs{DeclareTOCEntryStyle}, während der Hook innerhalb
% von \cs{DeclareTOCStyleEntry} ausgeführt wird. Der Code des Hooks hat ein
% Argument: Den Namen der Gliederungsebene.
%    \begin{macrocode}
%<*body>
\newcommand{\@AddToDeclareTOCEntryStylePreCheckNeeds}[1]{%
  \expandafter\providecommand\csname scr@dte@precheck\endcsname[1]{}%
  \expandafter\l@addto@macro@a\csname scr@dte@precheck\endcsname
}
\newcommand{\@PreToDeclareTOCEntryStylePreCheckNeeds}[1]{%
  \expandafter\providecommand\csname scr@dte@precheck\endcsname[1]{}%
  \expandafter\l@preto@macro@a\csname scr@dte@precheck\endcsname
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \@PreToDeclareTOCStyleEntryPreCheckNeeds
% \end{macro}^^A \@AddToDeclareTOCStyleEntryPreCheckNeeds
%
% \begin{macro}{\@TOCEntryStyleNeedsCommandByOption}
%   \changes{v3.20}{2015/12/04}{neu (intern)}
% Fügt einen oder mehrere Befehle der Liste der benötigten Befehle hinzu.
% \begin{description}
% \item[\marg{Stil}:] Der Stil \meta{string}, der die Befehle benötigt.
% \item[\marg{Präfix}:] Präfix \meta{string} des benötigten Befehls.
% \item[\marg{Postfix}:] Postfix \meta{string} des benötigten Befehls.
% \item[\marg{Option}:] Die Option \meta{string}, über die dieser Befehl
%   definiert wird.
% \item[\marg{Erklärung}:] Bedeutung \meta{string} des Befehls.
% \end{description}
% Zwischen Präfix und Postfix wird dann automatisch der Name der
% Gliederungsebene eingefügt.
%    \begin{macrocode}
%<*body>
\newcommand*{\@TOCEntryStyleNeedsCommandByOption}[5]{%
  \expandafter\providecommand\expandafter*\csname scr@dte@#1@needs\endcsname{}%
  \expandafter\l@addto@macro\csname scr@dte@#1@needs\endcsname{%
    \do{#2}{#3}{#4}{#5}%
  }%
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \@TOCEntryStyleNeedsCommandByOption
%
% \begin{macro}{\TOCEntryStyleInitCode}
%   \changes{v3.20}{2015/11/19}{neu}
% \begin{macro}{\TOCEntryStyleStartInitCode}
%   \changes{v3.20}{2015/11/25}{neu}
% Führt Befehle aus, bevor ein Verzeichnisbefehl in diesem Stil definiert wird
% und noch bevor die \emph{needs}-Liste abgearbeitet wird.
% Argumente sind:
% \begin{description}
% \item[\marg{Stil}:] Der Stil \meta{string} für den die Initialisierung
%   erfolgen soll.
% \item[\marg{Code}:] Wird zwecks Initialisierung ausgeführt. Innerhalb dieses
%   Codes ist \texttt{\#1} der Name der Verzeichnisebene.
% \end{description}
%    \begin{macrocode}
%<*body>
\newcommand{\TOCEntryStyleInitCode}[1]{%
  \scr@ifundefinedorrelax{scr@dte@#1@init}{%
    \expandafter\providecommand\expandafter*%
    \csname scr@dte@#1@init\endcsname[1]%
  }{%
    \expandafter\l@addto@macro@a\csname scr@dte@#1@init\endcsname
  }%
}
\newcommand{\TOCEntryStyleStartInitCode}[1]{%
  \scr@ifundefinedorrelax{scr@dte@#1@init}{%
    \expandafter\providecommand\expandafter*%
    \csname scr@dte@#1@init\endcsname[1]%
  }{%
    \expandafter\l@preto@macro@a\csname scr@dte@#1@init\endcsname
  }%
}
%    \end{macrocode}
% \end{macro}^^A \TOCEntryStyleStartInitCode
% \end{macro}^^A \TOCEntryStyleInitCode
% \begin{macro}{\@ExecuteTOCEntryStyleInitCode}
%   \changes{v3.20}{2015/12/04}{neu (intern)}
% Führt den Init-Code eines Stils aus. Das erste Argument ist der Name des
% Stils, das zweite der Name der Verzeichnisebene. Diesen erhält die
% Init-Anweisung außerdem als Argument.
%    \begin{macrocode}
\newcommand*{\@ExecuteTOCEntryStyleInitCode}[2]{%
  \let\scr@dte@doopts\@empty
  \scr@ifundefinedorrelax{scr@dte@#1@init}{}{%
    \def\DefineTOCEntryBooleanOption{\@DefineTOCEntryBooleanOption{#1}}%
    \def\DefineTOCEntryCommandOption{\@DefineTOCEntryCommandOption{#1}}%
    \def\DefineTOCEntryIfOption{\@DefineTOCEntryIfOption{#1}}%
    \def\DefineTOCEntryLengthOption{\@DefineTOCEntryLengthOption{#1}}%
    \def\DefineTOCEntryNumberOption{\@DefineTOCEntryNumberOption{#1}}%
    \def\DefineTOCEntryOption{\@DefineTOCEntryOption{#1}}%
    \def\AddToDeclareTOCEntryStylePreCheckNeeds{%
      \@AddToDeclareTOCEntryStylePreCheckNeeds{#1}}%
    \def\PreToDeclareTOCEntryStylePreCheckNeeds{%
      \@PreToDeclareTOCEntryStylePreCheckNeeds{#1}}%
    \def\TOCEntryStyleNeedsCommandByOption{%
      \@TOCEntryStyleNeedsCommandByOption{#1}}%
    \@nameuse{scr@dte@#1@init}{#2}%
    \let\TOCEntryStyleNeedsCommandByOption\relax
    \let\PreToDeclareTOCEntryStylePreCheckNeeds\relax
    \let\AddToDeclareTOCEntryStylePreCheckNeeds\relax
    \let\DefineTOCEntryOption\relax
    \let\DefineTOCEntryNumberOption\relax
    \let\DefineTOCEntryLengthOption\relax
    \let\DefineTOCEntryIfOption\relax
    \let\DefineTOCEntryCommandOption\relax
    \let\DefineTOCEntryBooleanOption\relax
  }%
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \ExecuteTOCEntryStyleInitCode
%
% \begin{macro}{\DeclareTOCStyleEntry}
%   \changes{v3.20}{2015/11/13}{neu}
% Diese Anweisung definiert einen Verzeichniseintragsbefehl. Dabei wird auch
% geprüft, ob all benötigten Befehle definiert sind. Falls das nicht der Fall
% ist, wird der Verzeichniseintragsbefehl nicht definiert, sondern ein Fehler
% gemeldet. Für die Definition werden folgende Argumente verwendet.
% \begin{description}
% \item[\oarg{Optionen}:] Komma separierte Liste von Optionen für die
%   Definition des Eintrags.
% \item[\marg{Stil}:] Der Stil \meta{string}, in dem der Verzeichniseintrag
%   sein soll.
% \item[\marg{Gliederungsebene}:] Der Name \meta{string} der Gliederungsebene
%   für die ein Verzeichniseintrag definiert werden soll.
% \end{description}
% Es wird außerdem eine Anweisung \cs{scr@dte@def@l@\meta{Stil}} benötigt,
% über die dann die eigentliche Definition der Eintragsanweisung
% erfolgt. Diese hat genau ein Argument: \meta{Gliederungsebene}.
%    \begin{macrocode}
%<*body>
\newcommand*{\DeclareTOCStyleEntry}[3][]{%
  \scr@ifundefinedorrelax{scr@dte@def@l@#2}{%
%<class>    \ClassError{\KOMAClassName
%<package>    \PackageError{tocbasic%
    }{toc entry style `#2' undefined}{%
      Somebody told me to define toc entry `#3' with style `#2',\MessageBreak
      but I do not know style `#2'.\MessageBreak
      You should first define the style then define the entry.\MessageBreak
      If you'll continue, I'll ignore the command. This could result
      in\MessageBreak
      further error messages.%
    }%
  }{%
    \let\scr@dte@precheck\@gobble
    \def\scr@dte@current{#3}%
    \@ExecuteTOCEntryStyleInitCode{#2}{#3}%
    \IfArgIsEmpty{#1}{}{%
      \FamilyBoolKey[.dte]{KOMAarg}{expandtopt}{scr@dte@expandtopt}%
      \scr@dte@expandtoptfalse
      \FamilyExecuteOptions[.dte]{KOMAarg}{#1}%
      \RelaxFamilyKey[.dte]{KOMAarg}{expandtopt}%
    }%
    \@RelaxTOCEntryOptions
    \let\scr@dte@doopts\relax
    \let\scr@dte@current\relax
    \scr@ifundefinedorrelax{#3tocdepth}{%
      \expandafter\let\csname #3tocdepth\expandafter\endcsname
      \csname #3numdepth\endcsname
    }{}%
    \scr@dte@precheck{#3}%
    \let\scr@dte@precheck\relax
    \begingroup
      \aftergroup\@tempswatrue
      \def\do##1##2##3##4{%
        \scr@ifundefinedorrelax{##1#3##2}{%
%<class>          \ClassError{\KOMAClassName
%<package>          \PackageError{tocbasic%
          }{toc style `#2' needs ##4}{%
            Usually the ##4 is defined using option `##3'.\MessageBreak
            In some cases it may be set defining command
            `\expandafter\string\csname ##1#3##2\endcsname'.\MessageBreak
            If you'll continue, I'll ignore the command. This could result
            in\MessageBreak
            further error messages.%
          }%
          \aftergroup\@tempswafalse
        }{}%
      }%
      \do{}{tocdepth}{level}{toc style level}%
      \@nameuse{scr@dte@#2@needs}%
    \endgroup
    \if@tempswa
      \@nameuse{scr@dte@def@l@#2}{#3}%
      \expandafter\edef\csname scr@dte@#3@style\endcsname{#2}%
%    \end{macrocode}
%   \changes{v3.21}{2016/06/09}{\cs{toclevel@\emph{ebene}} wird für
%     \textsf{hyperref} neu gesetzt}^^A
% Da verschiedene Pakete davon ausgehen, dass die Ebene
% \textsf{hyperref}-kompatibel gespeichert ist, setzen wir die hier
% zusätzlich. Das \textsf{hyperref} die Einstellungen ggf. überschreibt,
% machen wir das in der Dokumentpräambel auch mehrfach.
%    \begin{macrocode}
      \expandafter\let\csname toclevel@#3\expandafter\endcsname
      \csname #3tocdepth\endcsname
      \if@atdocument\else
        \scr@ifundefinedorrelax{AfterPackage}{%
          \AtBeginDocument
        }{%
          \AfterPackage*{hyperref}%
        }%
        {%
          \expandafter\let\csname toclevel@#3\expandafter\endcsname
          \csname #3tocdepth\endcsname
        }%
      \fi
    \fi
  }%
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \DeclareTOCStyleEntry
%
% \begin{macro}{\DeclareTOCEntryStyle}
%   \changes{v3.20}{2015/11/17}{neu}
% \begin{macro}{\@DeclareTOCEntryStyle}
%   \changes{v3.20}{2015/11/17}{neu (intern)}
% Über diese Anweisung wir ein neuer Stil für TOC-Einträge definiert. Ein Stil
% besteht aus:
% \begin{description}
% \item[\marg{Stil}:] Der Stil \meta{string}, der definiert werden soll.
% \item[\oarg{Initialisierungscode}:] Dieser Code wird bei der Definition
%   eines Verzeichnisbefehls ausgeführt und enthält beispielsweise
%   Optionendeklarationen. Es ist zu beachten, dass dieser Code ggf. auch
%   mehrfach ausgeführt werden kann!
% \item[\marg{Code}:] Der Code, der ausgeführt wird, wenn ein
%   Verzeichniseintrag ausgegeben werden soll.
% \end{description}
% Unabhängig davon, ob eine \meta{Optionendeklaration} angegeben ist oder
% nicht, wird immer eine Option \texttt{level} definiert, über die die
% Verzeichnisebene einen nummerischen Wert erhält.
%    \begin{macrocode}
%<*body>
\newcommand*{\DeclareTOCEntryStyle}[1]{%
  \kernel@ifnextchar [%]
    {\@DeclareTOCEntryStyle{#1}}%
    {\@DeclareTOCEntryStyle{#1}[]}%
}
\newcommand{\@DeclareTOCEntryStyle}{}
\long\def\@DeclareTOCEntryStyle#1[#2]#3{%
  \@namedef{scr@dte@def@l@#1}##1{%
    \@namedef{l@##1}####1####2{%
      \TOC@EntryStartHook{##1}%
      #3%
      \TOC@EntryEndHook{##1}%
    }%
  }%
  \TOCEntryStyleInitCode{#1}{%
    \DefineTOCEntryNumberOption{level}{}{tocdepth}{toc entry level}%
    #2%
  }%
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \@DeclareTOCEntryStyle
% \end{macro}^^A \DeclareTOCEntryStyle
%
% \begin{macro}{\TOC@EntryStartHook}
%   \changes{v3.20}{2016/01/12}{neu (intern)}
% Bei jedem Eintrag, der über einen Eintragsstil von \KOMAScript{} definiert
% ist, kann vor dem jeweiligen Eintrag über einen Haken eine Reihe
% von Anweisungen ausgeführt werden. Innerhalb dieser Anweisungen ist
% \texttt{\#1} der Name der Gliederungsebene. In der Regel dürfen diese
% Anweisungen keinerlei Ausgaben tätigen und weder \cs{lastpenalty} noch
% \cs{lastskip} verändern. Der Anwender ist dafür selbst verantwortlich! Weil
% diese Einschränkung jedoch etwas kritisch ist und der Aufruf ohnehin ein
% \cs{makeatletter} benötigt, wird nur der Haken definiert aber keine
% Anweisung, um diesen zu ändern oder zu erweitern.
%    \begin{macrocode}
%<*body>
\newcommand*{\TOC@EntryStartHook}[1]{}
%</body>
%    \end{macrocode}
% \end{macro}^^A \TOC@EntryStartHook
%
% \begin{macro}{\TOC@EntryEndHook}
%   \changes{v3.20}{2016/01/12}{neu (intern)}
% Bei jedem Eintrag, der über einen Eintragsstil von \KOMAScript{} definiert
% ist, kann nach dem jeweiligen Eintrag über einen Haken eine Reihe
% von Anweisungen ausgeführt werden. Innerhalb dieser Anweisungen ist
% \texttt{\#1} der Name der Gliederungsebene. In der Regel dürfen diese
% Anweisungen keinerlei Ausgaben tätigen und weder \cs{lastpenalty} noch
% \cs{lastskip} verändern. Der Anwender ist dafür selbst verantwortlich! Weil
% diese Einschränkung jedoch etwas kritisch ist und der Aufruf ohnehin ein
% \cs{makeatletter} benötigt,  wird nur der Haken definiert aber keine
% Anweisung, um diesen zu ändern oder zu erweitern.
%    \begin{macrocode}
%<*body>
\newcommand*{\TOC@EntryEndHook}[1]{}
%</body>
%    \end{macrocode}
% \end{macro}^^A \TOC@EntryEndHook
%
% \begin{macro}{\CloneTOCEntryStyle}
%   \changes{v3.20}{2015/11/25}{neu}
% Diese Anweisung dupliziert einen Stil samt seiner Optionen und
% Befehle. Anschließend kann man ihn beispielsweise verändern. Das erste
% Argument ist der Name des ursprünglichen Stils, das zweite der neue Name.
%    \begin{macrocode}
%<*body>
\newcommand*{\CloneTOCEntryStyle}[2]{%
%    \end{macrocode}
% Als erstes wird die Anweisung kopiert, mit der die \cs{l@\dots}-Anweisungen
% definiert werden.
%    \begin{macrocode}
  \expandafter\let\csname scr@dte@def@l@#2\expandafter\endcsname
  \csname scr@dte@def@l@#1\endcsname
%    \end{macrocode}
% Der Init-Code wird kopiert.
%    \begin{macrocode}
  \expandafter\let\csname scr@dte@#2@init\expandafter\endcsname
  \csname scr@dte@#1@init\endcsname
}
%</body>
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Vorgefertigte Verzeichniseintragsstile}
%
% Hier wird quasi an Beispielen gezeigt, wie man Verzeichniseintragsstile
% definieren kann. Einige dieser Stile sind sehr grundlegend. Andere sind
% stellen Erweiterungen der grundlegenden Stile dar. Die Stile können über
% mehrere \texttt{docstrip}-Durchgänge einzeln in den Quelltext gelangen.
%
% \iffalse
%<*style>
% \fi
%
% \begin{macro}{\scr@dte@def@l@gobble}
%   \changes{v3.20}{2015/11/20}{neuer Verzeichniseintragsstil
%     \texttt{gobble}}^^A
% Der aller einfachste Verzeichniseintragsstil ist \texttt{gobble}. Er nimmt
% die beiden Argumente für den Verzeichniseintrag und die Seitenzahl und
% vergisst sie unabhängig von der Ebene des Eintrags einfach. Daher benötigt
% dieser Stil auch keinerlei Optionen oder Initialisierung.
%    \begin{macrocode}
%<*gobble>
%%%            (run: style,gobble)
\DeclareTOCEntryStyle{gobble}{}%
%</gobble>
%    \end{macrocode}
% \end{macro}^^A \scr@dte@def@l@gobble
%
% \begin{macro}{\scr@dte@def@l@dottedtocline}
%   \changes{v3.20}{2015/11/20}{neuer Verzeichniseintragsstil
%     \texttt{dottedtocline}}^^A
% Der einfachste echte Verzeichniseintragsstil ist
% \texttt{dottedtocline}. Dieser verwendet einfach nur die
% \LaTeX-Kern-Anweisung \cs{dottedtocline}. Für \KOMAScript{} selbst sollte
% man dieses Stil nicht verwenden. Man kann ihn aber beispielsweise mit den
% Standardklassen verwenden, wenn man kompatibel bleiben will. Dieser benötigt
% jedoch bereits Angaben bezüglich der Nummernbreite und des
% Eintragseinzugs. Der ohnehin immer definierte Level wird ebenfalls
% ausgewertet.
% \begin{macro}{\scr@dte@def@l@undottedtocline}
%   \changes{v3.20}{2015/11/20}{neuer Verzeichniseintragsstil
%     \texttt{undottedtocline}}^^A
% Im Unterschied dazu entspricht der Verzeichniseintragsstil
% \texttt{undottedtocline} dem der \texttt{chapter}-Ebene der
% Standardklassen. Im Unterschied zu diesen wird jedoch ein Eintragseinzug
% unterstützt.
% \begin{macro}{\scr@dte@def@l@largetocline}
%   \changes{v3.20}{2015/11/20}{neuer Verzeichniseintragsstil
%     \texttt{largetocline}}^^A
% Im Unterschied dazu entspricht der Verzeichniseintragsstil
% \texttt{largetocline} dem der \texttt{part}-Ebene der Standardklassen. Im
% Unterschied zu diesen wird jedoch ein Eintragseinzug unterstützt. Eine
% Nummernbreite gibt es hingegen nicht. Stattdessen werden die Einträge nicht
% hängend gesetzt.
% \begin{macro}{\scr@dte@def@l@tocline}
%   \changes{v3.20}{2015/11/22}{neuer Verzeichniseintragsstil
%     \texttt{tocline}}^^A
% Das hingegen wird der hochflexible Stil für Verzeichniseinträge, die aus
% einer oder mehreren Zeilen bestehen. Dieser wird später über diverse
% Hilfsmakros definiert.
%    \begin{macrocode}
%<*dottedtocline|undottedtocline|largetocline|tocline>
%<*dottedtocline>
%%%            (run: style,dottedtocline)
\DeclareTOCEntryStyle{dottedtocline}[{%
%</dottedtocline>
%<*undottedtocline>
%%%            (run: style,undottedtocline)
\DeclareTOCEntryStyle{undottedtocline}[{%
%</undottedtocline>
%<*largetocline>
%%%            (run: style, largetocline)
\DeclareTOCEntryStyle{largetocline}[{%
%</largetocline>
%<*tocline>
%%%            (run: style,tocline)
\DeclareTOCEntryStyle{tocline}[{%
  \DefineTOCEntryLengthOption{beforeskip}%
    {scr@tso@}{@beforeskip}{vertical skip before the entry}%
  \DefineTOCEntryIfOption{breakafternumber}%
    {scr@tso@}{@breakafternumber}{line break after number flag}%
  \DefineTOCEntryIfOption{dynnumwidth}%
    {scr@tso@}{@dynnumwidth}{dynamic number width flag}%
  \DefineTOCEntryCommandOption{entryformat}%
    {scr@tso@}{@entryformat}[1]{entry format}%
  \DefineTOCEntryCommandOption{entrynumberformat}%
    {scr@tso@}{@numberformat}[1]{entry number format}%
  \DefineTOCEntryCommandOption{linefill}[\TOCLineLeaderFill]%
    {scr@tso@}{@linefill}{filling between text and page number}%
  \DefineTOCEntryLengthOption{numsep}%
    {scr@tso@}{@numsep}{entry number separation}%
  \DefineTOCEntryCommandOption{onstarthigherlevel}%
    {scr@tso@}{@LastTOCLevelWasLower}{start higher level entry hook}%
  \DefineTOCEntryCommandOption{onstartlowerlevel}%
    {scr@tso@}{@LastTOCLevelWasHigher}{start lower level entry hook}%
  \DefineTOCEntryCommandOption{onstartsamelevel}%
    {scr@tso@}{@LastTOCLevelWasSame}{start same level entry hook}%
  \DefineTOCEntryCommandOption{pagenumberbox}%
    {scr@tso@}{@pagenumberbox}[1]{page number box}%
  \DefineTOCEntryCommandOption{pagenumberformat}%
    {scr@tso@}{@pagenumberformat}[1]{page number format}%
%    \end{macrocode}
%   \changes{v3.21}{2016/06/06}{neue Option \texttt{raggedentrytext}}^^A
% Die Option \texttt{raggedentrytext} muss leider etwas umständlich definiert
% werden, damit sie mit der früheren Definition eines Makros
% \cs{raggedchapterentry} halbwegs kompatibel ist.
%    \begin{macrocode}
  \DefineTOCEntryOption{raggedentrytext}[true]{%
    \FamilySetBool{KOMAarg}{raggedentrytext}{@tempswa}{##1}%
    \ifx\FamilyKeyState\FamilyKeyStateProcessed
      \if@tempswa
        \expandafter\let\csname ragged\scr@dte@current entry\endcsname
        \raggedright
      \else
        \expandafter\let\csname ragged\scr@dte@current entry\endcsname
        \relax
      \fi
    \fi
  }%
  \DefineTOCEntryIfOption{raggedpagenumber}%
    {scr@tso@}{@raggedpage}{page number ragged flag}%
%</tocline>
  \DefineTOCEntryLengthOption{indent}%
    {scr@tso@}{@indent}{entry indent}%
%<*dottedtocline|undottedtocline|tocline>
  \DefineTOCEntryLengthOption{numwidth}%
    {scr@tso@}{@numwidth}{entry number width}%
%</dottedtocline|undottedtocline|tocline>
%    \end{macrocode}
% Die Ebene, \texttt{level} bzw. \cs{\dots tocdepth}, kann auf zweierlei Arten
% automatisch bestimmt werden. Zum einen wird für Sub-Ebenen die Elternebene
% um eins erhöht verwendet, falls die Elternebene bereits definiert ist.
%   \changes{v3.21}{2016/06/09}{\cs{the} eingefügt}^^A
%    \begin{macrocode}
%<*tocline>
  \scr@ifundefinedorrelax{#1tocdepth}{%
    \ifstrstart{#1}{sub}{%
      \scr@ifundefinedorrelax{\scr@dte@nosub{#1}tocdepth}{}{%
        \expandafter\edef\csname #1tocdepth\endcsname{%
          \the\numexpr \noexpand\@nameuse{\scr@dte@nosub{#1}tocdepth}+\@ne\relax
        }%
      }%
    }{}%
  }{}%
%</tocline>
%    \end{macrocode}
% War der Weg über Elternebenen nicht erfolgreich oder wurde er nicht
% verwendet, so werden Standardwerte angenommen, wie sie bei den
% Standardklassen und bei \KOMAScript{} zutreffen.
%    \begin{macrocode}
  \@ifundefined{#1tocdepth}{%
    \ifstr{#1}{part}{\@namedef{#1tocdepth}{-1}}{%
      \ifstr{#1}{chapter}{\@namedef{#1tocdepth}{0}}{%
        \ifstr{#1}{section}{\@namedef{#1tocdepth}{1}}{%
          \ifstr{#1}{subsection}{\@namedef{#1tocdepth}{2}}{%
            \ifstr{#1}{subsubsection}{\@namedef{#1tocdepth}{3}}{%
              \ifstr{#1}{paragraph}{\@namedef{#1tocdepth}{4}}{%
                \ifstr{#1}{subparagraph}{\@namedef{#1tocdepth}{5}}{%
                  \ifstr{#1}{figure}{\@namedef{#1tocdepth}{1}}{%
                    \ifstr{#1}{table}{\@namedef{#1tocdepth}{1}}{%
%    \end{macrocode}
% Für unbekannte Anweisungen wird stattdessen eine eventuell vorhandene
% Gliederungsebene auch als Verzeichnisebene übernommen:
%    \begin{macrocode}
                      \expandafter\let\csname #1tocdepth\expandafter\endcsname
                      \csname #1numdepth\endcsname
                    }%
                  }%
                }%
              }%
            }%
          }%
        }%
      }%
    }%
  }{}%
%    \end{macrocode}
% Der Einzug kann wie der Level aus der Elternebene gebildet werden
%    \begin{macrocode}
%<*tocline>
  \scr@ifundefinedorrelax{scr@tso@#1@indent}{%
    \@ifundefined{scr@#1@tocindent}{%
      \ifstrstart{#1}{sub}{%
        \scr@ifundefinedorrelax{scr@tso@\scr@dte@nosub{#1}@indent}{%
          \scr@ifundefinedorrelax{scr@tso@\scr@dte@nosub{#1}@numwidth}{}{%
            \expandafter\edef\csname scr@tso@#1@indent\endcsname{%
              \glueexpr \noexpand\@nameuse{scr@tso@\scr@dte@nosub{#1}@numwidth}%
              \relax
            }%
          }%
        }{%
          \scr@ifundefinedorrelax{scr@tso@\scr@dte@nosub{#1}@numwidth}{%
            \expandafter\edef\csname scr@tso@#1@indent\endcsname{%
              \glueexpr \noexpand\@nameuse{scr@tso@\scr@dte@nosub{#1}@indent}%
              \relax
            }%
          }{%
            \expandafter\edef\csname scr@tso@#1@indent\endcsname{%
              \glueexpr \noexpand\@nameuse{scr@tso@\scr@dte@nosub{#1}@indent}%
                       +\noexpand\@nameuse{scr@tso@\scr@dte@nosub{#1}@numwidth}%
              \relax
            }%
          }%
        }%
      }{}%
    }{%
%    \end{macrocode}
% Kompatibilität mit älteren \KOMAScript-Klassen.
%    \begin{macrocode}
      \@namedef{scr@tso@#1@indent}{\@nameuse{scr@#1@tocindent}}%
    }%
  }{}%
%</tocline>
%    \end{macrocode}
% War das nicht erfolgreich oder wird es nicht genutzt, so werden
% Standardwerte verwendet, die sowohl für die Standardklasse als auch die
% \KOMAScript-Klassen zutreffend sind.
%    \begin{macrocode}
  \@ifundefined{scr@tso@#1@indent}{%
%<*dottedtocline|undottedtocline|largetocline>
    \@ifundefined{scr@#1@tocindent}{%
%</dottedtocline|undottedtocline|largetocline>
      \ifstr{#1}{figure}{\@namedef{scr@tso@#1@indent}{1.5em}}{%
        \ifstr{#1}{table}{\@namedef{scr@tso@#1@indent}{1.5em}}{%
          \ifstr{#1}{part}{\@namedef{scr@tso@#1@indent}{0em}}{%
            \ifstr{#1}{chapter}{\@namedef{scr@tso@#1@indent}{0em}}{%
%    \end{macrocode}
% Ab hier hängt es nun davon ab, ob es eine Kapitel-Ebene gibt oder
% nicht. Dazu sollte die Kapitelebene bereits definiert sein!
%    \begin{macrocode}
              \scr@ifundefinedorrelax{l@chapter}{%
                \ifstr{#1}{section}{\@namedef{scr@tso@#1@indent}{0pt}}{%
                  \ifstr{#1}{subsection}{\@namedef{scr@tso@#1@indent}{1.5em}}{%
                    \ifstr{#1}{subsubsection}{%
                      \@namedef{scr@tso@#1@indent}{3.8em}%
                    }{%
                      \ifstr{#1}{paragraph}{%
                        \@namedef{scr@tso@#1@indent}{7em}%
                      }{%
                        \ifstr{#1}{subparagraph}{%
                          \@namedef{scr@tso@#1@indent}{10em}%
                        }{%
%    \end{macrocode}
% Für unbekannte Ebenen muss der Wert selbst per Option gesetzt werden!
%    \begin{macrocode}
                        }%
                      }%
                    }%
                  }%
                }%
              }{%
                \ifstr{#1}{section}{\@namedef{scr@tso@#1@indent}{1.5em}}{%
                  \ifstr{#1}{subsection}{\@namedef{scr@tso@#1@indent}{3.8em}}{%
                    \ifstr{#1}{subsubsection}{%
                      \@namedef{scr@tso@#1@indent}{7.0em}%
                    }{%
                      \ifstr{#1}{paragraph}{%
                        \@namedef{scr@tso@#1@indent}{10em}%
                      }{%
                        \ifstr{#1}{subparagraph}{%
                          \@namedef{scr@tso@#1@indent}{12em}%
                        }{%
%    \end{macrocode}
% Für unbekannte Ebenen muss der Wert selbst per Option gesetzt werden!
%    \begin{macrocode}
                        }%
                      }%
                    }%
                  }%
                }%
              }%
            }%
          }%
        }%
      }%
%<*dottedtocline|undottedtocline|largetocline>
    }{%
%    \end{macrocode}
% Kompatibilität mit älteren \KOMAScript-Klassen.
%    \begin{macrocode}
      \@namedef{scr@tso@#1@indent}{\@nameuse{scr@#1@tocindent}}%
    }%
%</dottedtocline|undottedtocline|largetocline>
  }{}%
%    \end{macrocode}
% Für die Nummernbreite gibt es ebenfalls beide Wege.
%    \begin{macrocode}
%<*dottedtocline|undottedtocline|tocline>
%<*tocline>
  \scr@ifundefinedorrelax{scr@tso@#1@numwidth}{%
    \scr@ifundefinedorrelax{scr@#1@tocnumwidth}{%
      \ifstrstart{#1}{sub}{%
        \scr@ifundefinedorrelax{scr@tso@\scr@dte@nosub{#1}@numwidth}{}{%
          \expandafter\edef\csname scr@tso@#1@numwidth\endcsname{%
            \glueexpr \noexpand\@nameuse{scr@tso@\scr@dte@nosub{#1}@numwidth}%
                     +.9em%
            \relax
          }%
        }%
      }{}%
    }{%
      \@namedef{scr@tso@#1@numwidth}{\@nameuse{scr@#1@tocnumwidth}}%
    }%
  }{}%
%</tocline>
  \@ifundefined{scr@tso@#1@numwidth}{%
%<*dottedtocline|undottedtocline>
    \@ifundefined{scr@#1@tocnumwidth}{%
%</dottedtocline|undottedtocline>
      \ifstr{#1}{figure}{\@namedef{scr@tso@#1@numwidth}{2.3em}}{%
        \ifstr{#1}{table}{\@namedef{scr@tso@#1@numwidth}{2.3em}}{%
          \ifstr{#1}{chapter}{\@namedef{scr@tso@#1@numwidth}{1.5em}}{%
%    \end{macrocode}
% Ab hier hängt es nun davon ab, ob es eine Kapitel-Ebene gibt oder
% nicht. Dazu sollte die Kapitelebene bereits definiert sein!
%    \begin{macrocode}
            \scr@ifundefinedorrelax{chapter}{%
              \ifstr{#1}{section}{\@namedef{scr@tso@#1@numwidth}{1.5em}}{%
                \ifstr{#1}{subsection}{\@namedef{scr@tso@#1@numwidth}{2.3em}}{%
                  \ifstr{#1}{subsubsection}{%
                    \@namedef{scr@tso@#1@numwidth}{3.2em}%
                  }{%
                    \ifstr{#1}{paragraph}{%
                      \@namedef{scr@tso@#1@numwidth}{4.1em}%
                    }{%
                      \ifstr{#1}{subparagraph}{%
                        \@namedef{scr@tso@#1@numwidth}{5m}%
                      }{%
%    \end{macrocode}
% Für unbekannte Ebenen muss der Wert selbst per Option gesetzt werden!
%    \begin{macrocode}
                      }%
                    }%
                  }%
                }%
              }%
            }{%
              \ifstr{#1}{section}{\@namedef{scr@tso@#1@numwidth}{2.3em}}{%
                \ifstr{#1}{subsection}{\@namedef{scr@tso@#1@numwidth}{3.2em}}{%
                  \ifstr{#1}{subsubsection}{%
                    \@namedef{scr@tso@#1@numwidth}{3.1em}%
                  }{%
                    \ifstr{#1}{paragraph}{%
                      \@namedef{scr@tso@#1@numwidth}{5em}%
                    }{%
                      \ifstr{#1}{subparagraph}{%
                        \@namedef{scr@tso@#1@numwidth}{6em}%
                      }{%
%    \end{macrocode}
% Für unbekannte Ebenen muss der Wert selbst per Option gesetzt werden!
%    \begin{macrocode}
                      }%
                    }%
                  }%
                }%
              }%
            }%
          }%
        }%
      }%
%<*dottedtocline|undottedtocline>
    }{%
%    \end{macrocode}
% Kompatibilität mit älteren \KOMAScript-Klassen.
%    \begin{macrocode}
      \@namedef{scr@tso@#1@numwidth}{\@nameuse{scr@#1@tocnumwidth}}%
    }%
%</dottedtocline|undottedtocline>
  }{}%
%</dottedtocline|undottedtocline|tocline>
%<*tocline>
%    \end{macrocode}
% Die Standardeinstellungen für die drei Penalty-Hooks sind einfach die
% Standardanweisungen dafür. Dabei ist das so definiert, dass Änderungen an
% den Standardanweisungen direkte Auswirkungen haben.
%    \begin{macrocode}
  \expandafter\providecommand%
  \csname scr@tso@#1@LastTOCLevelWasLower\endcsname{\LastTOCLevelWasLower}%
  \expandafter\providecommand%
  \csname scr@tso@#1@LastTOCLevelWasSame\endcsname{\LastTOCLevelWasSame}%
  \expandafter\providecommand%
  \csname scr@tso@#1@LastTOCLevelWasHigher\endcsname{\LastTOCLevelWasHigher}%
%    \end{macrocode}
% Die Voreinstellung für den vertikalen Abstand ist Null mit ein klein wenig
% Leim, um den Seitenumbruch zu optimieren. Das genügt bei einer normalen
% A4-Seite aber gerade mal für den Ausgleich einer Zeile. Bei den höheren
% Ebenen werden stattdessen die Voreinstellungen der Standardklassen
% verwendet.
%    \begin{macrocode}
  \@ifundefined{scr@tso@#1@beforeskip}{%
    \ifstr{#1}{part}{%
      \@namedef{scr@tso@#1@beforeskip}{\glueexpr 2.25em \@plus\p@\relax}%
    }{%
      \ifstr{#1}{chapter}{%
        \@namedef{scr@tso@#1@beforeskip}{\glueexpr 1.0em \@plus\p@\relax}%
      }{%
        \ifstr{#1}{section}{%
          \scr@ifundefinedorrelax{l@chapter}{%
            \@namedef{scr@tso@#1@beforeskip}{\glueexpr 1.0em \@plus\p@\relax}%
          }{}%
        }{}%
      }%
    }%
    \expandafter\providecommand\expandafter*%
    \csname scr@tso@#1@beforeskip\endcsname{\glueexpr \z@ plus .2\p@\relax}%
  }{}%
%    \end{macrocode}
% Es ist gut zu wissen, wie breit die breiteste Nummer ist, damit wir
% ggf. prüfen können, ob entsprechende Bedingungen eingehalten werden.
%    \begin{macrocode}
  \@ifundefined{scr@dte@#1@maxnumwidth}{%
    \expandafter\newlength\csname scr@dte@#1@maxnumwidth\endcsname
    \setlength{\@nameuse{scr@dte@#1@maxnumwidth}}{\z@}%
  }{}%
  \providecommand*{\scr@dte@donumwidth}{}%
  \g@addto@macro{\scr@dte@donumwidth}{\do{#1}}%
%    \end{macrocode}
% Eine dieser Bedingungen ist, dass ein Mindestabstand zwischen Nummer und
% Text eingehalten wird.
%    \begin{macrocode}
  \expandafter\providecommand\expandafter*%
  \csname scr@tso@#1@numsep\endcsname{.4em}%
%    \end{macrocode}
% Jede Ebene kann ihre eigene Formatierungsanweisung für die Nummer haben.
% Jede Ebene kann auch ihre eigene Formatierungsanweisung für Nummer und Text
% haben. Für \texttt{part} wird hier die Voreinstellung der Standardklassen
% verwendet.
%    \begin{macrocode}
  \expandafter\providecommand%
  \csname scr@tso@#1@numberformat\endcsname[1]{##1}%
  \ifstr{#1}{part}{%
    \expandafter\providecommand%
    \csname scr@tso@#1@entryformat\endcsname[1]{\large\bfseries ##1}%
  }{%
    \ifstr{#1}{chapter}{%
      \expandafter\providecommand%
      \csname scr@tso@#1@entryformat\endcsname[1]{\bfseries ##1}%
    }{%
      \scr@ifundefinedorrelax{l@chapter}{%
        \ifstr{#1}{section}{%
          \expandafter\providecommand%
          \csname scr@tso@#1@entryformat\endcsname[1]{\bfseries ##1}%
        }{}%
      }{}%
      \expandafter\providecommand%
      \csname scr@tso@#1@entryformat\endcsname[1]{##1}%
    }%
  }%
%    \end{macrocode}
% Nach der Nummer kann wahlweise ein Zeilenumbruch erfolgen, wobei in diesem
% Fall der Text wieder auf Höhe der Nummer und nicht erst danach
% erfolgt. Gesteuert wird das über einen Schalter. In der Voreinstellung
% machen wird das nicht.
%    \begin{macrocode}
  \expandafter\providecommand
  \csname Ifscr@tso@#1@breakafternumber\endcsname[2]{##2}%
%    \end{macrocode}
% Die Verbindung zwischen Ende des Eintrags und den Seitenzahlen erfolgt
% normalerweise mit Pünktchen. Das wird auch genau die Voreinstellung für die
% Option werden. In der Voreinstellung wird mit \cs{hfill} gefüllt.
%    \begin{macrocode}
  \@ifundefined{scr@tso@#1@linefill}{%
    \ifstr{#1}{part}{%
      \@namedef{scr@tso@#1@linefill}{\hfill}%
    }{%
      \ifstr{#1}{chapter}{%
        \@namedef{scr@tso@#1@linefill}{\hfill}%
      }{%
        \scr@ifundefinedorrelax{l@chapter}{%
          \ifstr{#1}{section}{%
            \@namedef{scr@tso@#1@linefill}{\hfill}%
          }{}%
        }{}%
        \expandafter\providecommand%
        \csname scr@tso@#1@linefill\endcsname{\TOCLineLeaderFill\relax}%
      }%
    }%
  }{}%
%    \end{macrocode}
% Keine Verbindung bedeutet nicht automatisch, dass die Seitenzahlen nach vorn
% rutschen. Das passiert erst, wenn die sie flatternd gesetzt werden:
%    \begin{macrocode}
  \expandafter\providecommand\csname Ifscr@tso@#1@raggedpage\endcsname[2]{##2}%
%    \end{macrocode}
% Auch die Seitenzahl kann speziell formatiert werden, wenn das gewünscht ist.
%    \begin{macrocode}
  \ifstr{#1}{part}{%
%    \end{macrocode}
% Für \texttt{part} normalerweise groß und fett:
%    \begin{macrocode}
    \expandafter\providecommand%
    \csname scr@tso@#1@pagenumberformat\endcsname[1]{\large\bfseries ##1}%
  }{%
%    \end{macrocode}
% \changes{v3.25}{2017/11/23}{Seitenzahlen für \texttt{chapter}-Einräge in der
%   Voreinstellung fett}^^A
% Für \texttt{chapter} nur fett:
%    \begin{macrocode}
    \ifstr{#1}{chapter}{%
      \expandafter\providecommand%
      \csname scr@tso@#1@pagenumberformat\endcsname[1]{\bfseries ##1}%
    }{%
      \scr@ifundefinedorrelax{l@chapter}{%
        \ifstr{#1}{section}{%
%    \end{macrocode}
% \changes{v3.25}{2017/11/23}{Seitenzahlen für \texttt{section}-Einräge in der
%   Voreinstellung unter Umständen fett}^^A
% Für \texttt{section} ggf. auch fett:
%    \begin{macrocode}
          \expandafter\providecommand%
          \csname scr@tso@#1@pagenumberformat\endcsname[1]{\bfseries ##1}%
        }{}%
      }{}%
%    \end{macrocode}
% Sonst in normaler Schrift und Farbe:
%    \begin{macrocode}
      \expandafter\providecommand%
      \csname scr@tso@#1@pagenumberformat\endcsname[1]{%
        \normalfont\normalcolor ##1}%
    }%
  }%
%    \end{macrocode}
% Wobei die Seitenzahl normaleweise in eine Box fester Breite gesetzt wird.
%    \begin{macrocode}
  \expandafter\providecommand%
  \csname scr@tso@#1@pagenumberbox\endcsname[1]{%
    \hb@xt@\@pnumwidth{\hfil ##1}}%
  \expandafter\providecommand\csname Ifscr@tso@#1@dynnumwidth\endcsname[2]{##2}%
%</tocline>
}]{%
%    \end{macrocode}
% Damit ist die Initialisierung abgeschlossen und wir kommen zur
% Eintragsanweisung selbst:
%    \begin{macrocode}
%<*dottedtocline>
  \@dottedtocline{\@nameuse{#1tocdepth}}{\@nameuse{scr@tso@#1@indent}}%
                 {\@nameuse{scr@tso@#1@numwidth}}{##1}{##2}%
%</dottedtocline>
%<*undottedtocline|largetocline>
  \ifnum \c@tocdepth >\numexpr \@nameuse{#1tocdepth}-\@ne\relax
%    \end{macrocode}
% An dieser Stelle gibt es einen kleinen Unterschied zwischen der
% \texttt{chapter}-Ebene und der \texttt{section}-Ebene von
% \textsf{article}. Diesen machen wir hier an der nummerischen Ebene fest.
%    \begin{macrocode}
    \ifnum \@nameuse{#1tocdepth}<\@ne
      \scr@ifundefinedorrelax{chapter}{%
        \addpenalty\@secpenalty
%<undottedtocline>        \addvspace{1.0em \@plus\p@}%
%<largetocline>        \addvspace{2.25em \@plus\p@}%
      }{%
        \addpenalty{-\@highpenalty}%
%<undottedtocline>        \vskip 1.0em \@plus\p@
%<largetocline>        \addvspace{2.25em \@plus\p@}%
      }%
    \else
      \addpenalty\@secpenalty
%<undottedtocline>      \addvspace{1.0em \@plus\p@}%
%<largetocline>      \addvspace{2.25em \@plus\p@}%
    \fi
%<undottedtocline>    \setlength\@tempdima{\@nameuse{scr@tso@#1@numwidth}}%
%<largetocline>    \setlength\@tempdima{3em}%
    \begingroup
%    \end{macrocode}
% Es sei darauf hingewiesen, dass hier eigentlich zweimal \cs{@tocrmarg}
% statt \cs{@pnumwidth} verwendet werden müsste. Allerdings habe ich
% beschlossen, diesen schon vor Jahren gemeldeten Fehler aus
% Kompatibilitätsgründen vorerst von den Standardklassen zu übernehmen.
%    \begin{macrocode}
      \parindent \z@ \rightskip \@pnumwidth
      \parfillskip -\@pnumwidth
%    \end{macrocode}
% Die Standardklassen fügen an dieser Stelle noch eine Gruppe ein, die dann
% leider vor dem abschließenden \cs{par} bereits beendet wird. Das führt
% natürlich zu falschen Zeilenabständen bei mehrzeiligen Einträgen. Ich habe
% lange überlegt, aber schließlich beschlossen, diesen Fehler nicht aus den
% Standardklassen zu übernehmen. Das war mir dann doch zu krass! Schlimmer
% noch, würde man den Fehler übernehmen, müsste man das Setzen von
% \cs{leftskip} abändern, weil natürlich auch das erst am Absatzende
% wirklich zur Geltung kommt.
%    \begin{macrocode}
      \leavevmode
%<largetocline>      \large
      \bfseries
%    \end{macrocode}
% Es sei darauf hingewiesen, dass hier eigentlich auch bei
% \texttt{largetocline} \cs{@tempdima} mit berücksichtigt werden
% müsste. Das geht nur deshalb nicht, weil bei den Standardklassen \cs{part}
% kein \cs{numberline} verwendet. Deshalb werden mehrzeilige Einträge auch
% nicht korrekt eingerückt. Auch das habe ich aus Kompatibilitätsgründen
% beibehalten.
%    \begin{macrocode}
%<undottedtocline>      \advance\leftskip\@tempdima
      \advance\leftskip\@nameuse{scr@tso@#1@indent}%
%<*undottedtocline>
      \hskip -\dimexpr \leftskip-\@nameuse{scr@tso@#1@indent}\relax
%</undottedtocline>
      ##1%
%<undottedtocline>      \nobreak
%    \end{macrocode}
% Hier schließlich ist \cs{@pnumwidth} aufgrund des vorherigen
% \cs{large} nicht mehr derselbe absolute Wert wie bei Einträgen ohne
% \cs{large}. Deshalb müsste eigentlich noch vor dem \cs{large} der Wert
% beispielsweise in eine Länge wie \cs{@tempdimb} übertragen und dann hier
% verwendet werden. Auch das habe ich aus Kompatibilitätsgründen übernommen.
%    \begin{macrocode}
      \hfil \nobreak\hb@xt@\@pnumwidth{\hss ##2}%
      \par
%<undottedtocline>      \penalty\@highpenalty
%<*largetocline>
      \nobreak
      \ifnum 0=
        \scr@ifundefinedorrelax{chapter}{\if@compatibility 1\else 0\fi}{1}\relax
        \global\@nobreaktrue
        \everypar{\global\@nobreakfalse\everypar{}}%
      \fi
%</largetocline>
    \endgroup
  \fi
%</undottedtocline|largetocline>
%<*tocline>
  \scr@dte@tocline{#1}{##1}{##2}%
%</tocline>
}
%</dottedtocline|undottedtocline|largetocline|tocline>
%    \end{macrocode}
% \end{macro}^^A \scr@dte@def@l@tocline
% \end{macro}^^A \scr@dte@def@l@largetocline
% \end{macro}^^A \scr@dte@def@l@undottedtocline
% \end{macro}^^A \scr@dte@def@l@dottedtocline
%
% Für den Stil \texttt{tocline} werden diverse weitere Einstellungen und
% Befehle benötigt:
%    \begin{macrocode}
%<*tocline>
\AtBeginDocument{%
  \BeforeClosingMainAux{%
    \begingroup
      \def\do#1{%
        \relax
        \scr@ifundefinedorrelax{scr@dte@#1@maxnumwidth}{}{%
          \ifdim \@nameuse{scr@dte@#1@maxnumwidth}>\z@
            \if@filesw
              \protected@write\@mainaux{}{%
                \string\global\string\@namedef{scr@dte@#1@lastmaxnumwidth}%
                {\the\@nameuse{scr@dte@#1@maxnumwidth}}%
              }%
            \fi
            \@nameuse{scr@dte@#1@maxnumwidth}\z@
          \fi
        }%
      }%
      \@nameuse{scr@dte@donumwidth}%
    \endgroup
  }%
}
%    \end{macrocode}
% \begin{macro}{\scr@dte@nosub}
%   \changes{v3.20}{2015/11/23}{neu (intern)}
% \begin{macro}{\@scr@dte@nosub}
%   \changes{v3.20}{2015/11/23}{neu (intern)}
% Über diese Hilfsmacros werden die Buchstaben \texttt{sub} am Anfang des
% Arguments entfernt. Stehen diese gar nicht am Anfang, so wird ein Fehler
% wegen falscher Verwendung von \cs{@scr@de@nosub} gemeldet.
%    \begin{macrocode}
\newcommand*{\scr@dte@nosub}[1]{\@scr@dte@nosub #1\relax}
\newcommand*{\@scr@dte@nosub}{}
\def\@scr@dte@nosub sub#1\relax{#1}
%    \end{macrocode}
% \end{macro}^^A \@scr@dte@nosub
% \end{macro}^^A \scr@dte@nosub
% \begin{macro}{\scr@dte@tocline}
%   \changes{v3.20}{2015/11/22}{neu (intern)}
% In gewisser Weise entspricht diese Anweisung der \LaTeX-Kern-Anweisung
% \cs{dottedtocline}. Allerdings werden hier vielfältige
% Eingriffsmöglichkeiten untersützt, die jeweils durch Optionen gesteuert
% werden können. Daher hat der Befehl auch nur drei Argumente:
% \begin{description}
% \item[\marg{Ebene}:] Der Name \meta{string} der Verzeichnisebene.
% \item[\marg{Eintrag}:] Der Verzeichniseintrag \meta{string}.
% \item[\marg{Seite}:] Die Seitenzahl \meta{string} des Verzeichniseintrags.
% \end{description}
% \begin{Length}{\scr@dte@tocline@numberwidth}
%   \changes{v3.20}{2016/01/15}{neu (intern)}
% Für alle, die es interessiert, gibt diese Länge die tatsächliche Breite der
% formatierten Nummer an.
%    \begin{macrocode}
\newlength\scr@dte@tocline@numberwidth
\newcommand*{\scr@dte@tocline}[3]{%
  \ifnum \@nameuse{#1tocdepth}>\c@tocdepth
  \else
    \tocbasic@DependOnPenaltyAndTOCLevel{#1}%
    \addvspace{\@nameuse{scr@tso@#1@beforeskip}}\relax
    {%
      \leftskip \@nameuse{scr@tso@#1@indent}\relax 
      \rightskip \@tocrmarg
      \parfillskip -\rightskip
      \@nameuse{Ifscr@tso@#1@raggedpage}{%
        \addtolength{\parfillskip}{\z@ \@plus 1fil}%
      }{}%
      \parindent \@nameuse{scr@tso@#1@indent}\relax
      \@afterindenttrue
      \interlinepenalty\@M
%    \end{macrocode}
%   \changes{v3.21}{2016/06/06}{\cs{ragged\dots entry} wird (wieder)
%     ausgewertet}^^A
%    \begin{macrocode}
      \expandafter\ifx\csname ragged#1entry\endcsname\raggedright
        \addtolength\rightskip\@flushglue
      \else
        \def\reserved@a{\raggedright}%
        \expandafter\ifx\csname ragged#1entry\endcsname\reserved@a
          \addtolength\rightskip\@flushglue
        \else
          \renewcommand\reserved@a{\raggedright}%
          \expandafter\ifx\csname ragged#1entry\endcsname\reserved@a
            \addtolength\rightskip\@flushglue
          \fi
        \fi
      \fi
      \leavevmode
      \@tempdima \@nameuse{scr@tso@#1@numwidth}\relax
      \@nameuse{Ifscr@tso@#1@dynnumwidth}{%
        \scr@ifundefinedorrelax{scr@dte@#1@lastmaxnumwidth}{}{%
          \ifdim \@nameuse{scr@dte@#1@lastmaxnumwidth}>\@tempdima
            \@tempdima\@nameuse{scr@dte@#1@lastmaxnumwidth}\relax
          \fi
        }%
      }{}%
      \advance\leftskip \@tempdima 
      \null\nobreak\hskip -\leftskip
      {%
%    \end{macrocode}
% An dieser Stelle wenden wir einen Trick an, um die Breite einer eventuell
% vorhandenen Nummer während deren Ausgabe auszumessen. Dazu ist es eine
% schlichte Notwendigkeit, dass \cs{numberline} die interne Definition
% verwendet.
%    \begin{macrocode}
        \usetocbasicnumberline
        \let\scr@dte@numberline@box\numberline@box
        \def\numberline@box##1{%
          \sbox\scr@dte@tocline@numbox{\@nameuse{scr@tso@#1@numberformat}{##1}}%
%    \end{macrocode}
% Die Zuweisung an die aktuelle Länge der Nummer muss global erfolgen, weil
% wir hier in einer Gruppe sind.
% \changes{v3.22}{2016/12/02}{fehlendes zweites \cs{relax} ergänzt}^^A
%    \begin{macrocode}
          \global\scr@dte@tocline@numberwidth
          \dimexpr\wd\scr@dte@tocline@numbox+\@nameuse{scr@tso@#1@numsep}\relax
%    \end{macrocode}
% \changes{v3.22}{2016/12/02}{fehlendes zweites \cs{relax} ergänzt}^^A
% Achtung: Hier braucht es ein zweites \cs{relax}, weil das erste von
% \cs{dimexpr} aufgezehrt wird.
%    \begin{macrocode}
          \relax
          \ifdim \scr@dte@tocline@numberwidth
                >\@nameuse{scr@dte@#1@maxnumwidth}\relax
            \global\@nameuse{scr@dte@#1@maxnumwidth}\scr@dte@tocline@numberwidth
          \fi
          \@nameuse{Ifscr@tso@#1@dynnumwidth}{}{%
            \ifdim \scr@dte@tocline@numberwidth
                  >\dimexpr \@nameuse{scr@tso@#1@numwidth}%
                           +\@nameuse{scr@tso@#1@numsep}\relax\relax
%<class>              \ClassWarning{\KOMAClassName
%<package>              \PackageWarning{tocbasic%
              }{%
                number width of #1 toc entries should be
                increased!\MessageBreak
                Currently used number width =
                \the\wd\scr@dte@tocline@numbox,\MessageBreak
                Wanted number separation
                \space\space\space =
                \the\dimexpr\@nameuse{scr@tso@#1@numsep}\relax,\MessageBreak
                Reserved number width \space\space\space\space\space\space =
                \the\dimexpr\@nameuse{scr@tso@#1@numwidth}\relax%
              }%
            \fi
          }%
          \scr@dte@numberline@box{\@nameuse{scr@tso@#1@numberformat}{##1}}%
          \@nameuse{Ifscr@tso@#1@breakafternumber}{%
            {\parfillskip\@flushglue\par}\nobreak\hskip-\leftskip
          }{}%
        }%
        \@nameuse{scr@tso@#1@entryformat}{%
          #2%
          \nobreak
          {%
            \normalfont\normalsize\@nameuse{scr@tso@#1@linefill}%
            \nobreak
            \@nameuse{scr@tso@#1@pagenumberbox}{%
              \@nameuse{scr@tso@#1@pagenumberformat}{#3}%
            }%
          }%
          \@par
        }%
      }%
    }%
    \tocbasic@SetPenaltyByTOCLevel{#1}%
  \fi
}
%    \end{macrocode}
% \end{Length}^^A \scr@dte@tocline@numberwidth
% \begin{macro}{\scr@dte@tocline@numbox}
%   \changes{v3.20}{2015/11/25}{neue Box (intern)}
% Wird benötigt, um die Breite der Nummer auszumessen und die Nummer später
% wieder zu verwenden.
%    \begin{macrocode}
\newsavebox\scr@dte@tocline@numbox
%    \end{macrocode}
% \end{macro}^^A \scr@dte@tocline@numbox
% \begin{macro}{\tocbasic@DependOnPenaltyAndTOCLevel}
%   \changes{v3.20}{2015/11/23}{neu}^^A
%   \changes{v3.20}{2016/03/12}{Anpassung an \textsf{tocbasic}-Syntax für
%     Befehle für Paketautoren}^^A
% Führt eine gespeicherte Aktion in Abhängigkeit davon aus, ob der aktuelle
% Penalty-Wert darauf schließen lässt, dass zuvor ein Eintrag mit einem
% höheren, demselben oder einem tieferen Wert für die Ebene erfolgte.
% \begin{macro}{\tocbasic@SetPenaltyByTOCLevel}
%   \changes{v3.20}{2015/11/23}{neu}
%   \changes{v3.20}{2016/03/12}{Anpassung an \textsf{tocbasic}-Syntax für
%     Befehle für Paketautoren}^^A
% Setze die Strafpunkte für einen Umbruch entsprechend der aktuellen
% Verzeichnisebene.
% \begin{macro}{\LastTOCLevelWasHigher}
%   \changes{v3.20}{2015/11/23}{neu}
% Standardaktion, falls der vorherige Level einen größeren Wert hatte: Umbruch
% erlauben.
% \begin{macro}{\LastTOCLevelWasSame}
%   \changes{v3.20}{2015/11/23}{neu}
% Standardaktion, falls der vorherige Level denselben Wert hatte: Umbruch
% erlauben.
% \begin{macro}{\LastTOCLevelWasLower}
% Standardaktion, falls der vorherige Level einen kleineren Wert hatte:
% Penalty beibehalten und damit den Umbruch verbieten.
%   \changes{v3.20}{2015/11/23}{neu}
%    \begin{macrocode}
\newcommand*{\tocbasic@DependOnPenaltyAndTOCLevel}[1]{%
  \ifnum \lastpenalty<\numexpr 20009-\@nameuse{#1tocdepth}\relax
    \@nameuse{scr@tso@#1@LastTOCLevelWasHigher}%
  \else\ifnum \lastpenalty=\numexpr 20009-\@nameuse{#1tocdepth}\relax
      \@nameuse{scr@tso@#1@LastTOCLevelWasSame}%
    \else
      \@nameuse{scr@tso@#1@LastTOCLevelWasLower}%
    \fi
  \fi
}
\newcommand*{\tocbasic@SetPenaltyByTOCLevel}[1]{%
  \penalty \numexpr 20009-\@nameuse{#1tocdepth}\relax
}
\newcommand*{\LastTOCLevelWasHigher}{\ifvmode\addpenalty{\@lowpenalty}\fi}
\newcommand*{\LastTOCLevelWasSame}{\ifvmode\addpenalty{\@lowpenalty}\fi}
\newcommand*{\LastTOCLevelWasLower}{}
%    \end{macrocode}
% \end{macro}^^A \tocbasic@SetPenaltyByTOCLevel
% \end{macro}^^A \tocbasic@DependOnPenaltyAndTOCLevel
% \end{macro}^^A \LastTOCLevelWasLower
% \end{macro}^^A \LastTOCLevelWasSame
% \end{macro}^^A \LastTOCLevelWasHigher
% \begin{macro}{\TOCLineLeaderFill}
%   \changes{v3.20}{2015/11/14}{neu}
% Füllt den Abstand zwischen Text und Seitenzahl komplett. Hat als einziges
% optionales Argument das Füllzeichen.
%    \begin{macrocode}
\newcommand*{\TOCLineLeaderFill}[1][.]{%
  \leaders\hbox{$\m@th
    \mkern \@dotsep mu\hbox{#1}\mkern \@dotsep
    mu$}\hfill
}
%</tocline>
%    \end{macrocode}
% \end{macro}^^A \TOCLineLeaderFill
% \end{macro}^^A \scr@dte@tocline
%
% \begin{macro}{\scr@dte@def@l@default}
%   \changes{v3.20}{2015/12/16}{neu im Paket}^^A
% Bereits im Paket gibt es einen Standardstil. Anderen Paketen ist es nicht
% gestattet diesen umzudefinieren. Klassen ist das hingegen gestattet, damit
% sie einen Dokument weiten Standardstil festlegen können.
%    \begin{macrocode}
%<*default>
%%%            (run: style,dottedtocline)
\CloneTOCEntryStyle{dottedtocline}{default}
%</default>
%    \end{macrocode}
% \end{macro}
%
% \iffalse
%</style>
%</package>
% \fi
%
% \subsubsection{Von den \KOMAScript-Klassen genutzte Stile}
%
% \iffalse
%<*class>
%<*style>
% \fi
%
% Einige Stile sollen nur definiert werden, wenn die Definition in die Klasse
% geschrieben wird:
%
% \begin{macro}{\scr@dte@def@l@part}
%   \changes{v3.20}{2015/12/07}{neuer Verzeichnisstil \texttt{part}}^^A
% Dieser Verzeichnisstil existiert bei \textsf{scrbook}, \textsf{scrreprt} und
% \textsf{scrartcl}. Das Format des Eintrags und der Seitenzahl wird dabei
% über die Elemente \texttt{partentry} und \texttt{partentrypagenumber}
% realisiert.
%    \begin{macrocode}
%<*part>
%%%            (run: class,style,part)
\CloneTOCEntryStyle{tocline}{part}
\TOCEntryStyleStartInitCode{part}{%
  \expandafter\providecommand%
  \csname scr@tso@#1@linefill\endcsname{\hfill}%
  \expandafter\providecommand%
  \csname scr@tso@#1@entryformat\endcsname[1]{\usekomafont{partentry}{##1}}%
  \expandafter\providecommand%
  \csname scr@tso@#1@pagenumberformat\endcsname[1]{%
    \usekomafont{partentry}{\usekomafont{partentrypagenumber}{##1}}}%
  \expandafter\providecommand\expandafter*%
  \csname scr@tso@#1@beforeskip\endcsname{2.25em \@plus\p@}%
}
%</part>
%    \end{macrocode}
% \end{macro}^^A \scr@dte@def@l@part
%
% \begin{macro}{\scr@dte@def@l@chapter}
%   \changes{v3.20}{2015/12/07}{neuer Verzeichnisstil \texttt{chapter}}^^A
% Dieser Verzeichnisstil existier bei \textsf{scrbook} und \textsf{scrreprt}.
%    \begin{macrocode}
%<*chapter>
%%%            (run: class,style,chapter)
\CloneTOCEntryStyle{tocline}{chapter}
\TOCEntryStyleStartInitCode{chapter}{%
  \expandafter\providecommand%
  \csname scr@tso@#1@linefill\endcsname{%
    \if@chapterentrywithdots
      \TOCLineLeaderFill\relax
    \else
      \hfill
    \fi
  }%
  \expandafter\providecommand%
  \csname scr@tso@#1@entryformat\endcsname{\usekomafont{chapterentry}}%
  \expandafter\providecommand%
  \csname scr@tso@#1@pagenumberformat\endcsname[1]{%
    \usekomafont{chapterentry}{\usekomafont{chapterentrypagenumber}{##1}}}%
  \expandafter\providecommand\expandafter*%
  \csname scr@tso@#1@beforeskip\endcsname{1.0em \@plus\p@}%
}
%</chapter>
%    \end{macrocode}
% \end{macro}^^A \scr@dte@def@l@chapter
%
% \begin{macro}{\scr@dte@def@l@section}
%   \changes{v3.20}{2015/12/07}{neuer Verzeichnisstil \texttt{section}}^^A
% Bei den Klassen \textsf{scrbook} und \textsf{scrreprt} ist das der Stil für
% die \emph{kleinen} Verzeichnisebenen. Bei \textsf{scrartcl} ist es dagegen
% der Stil für die obere Verzeichnisebene und entspricht damit obigem Stil
% \texttt{chapter}.
%    \begin{macrocode}
%<*section>
%%%            (run: class,style,section)
\CloneTOCEntryStyle{tocline}{section}
%<*book|report>
\TOCEntryStyleStartInitCode{section}{%
  \expandafter\providecommand%
  \csname scr@tso@#1@linefill\endcsname{\TOCLineLeaderFill\relax}%
}
%</book|report>
%<*article>
\TOCEntryStyleStartInitCode{section}{%
  \expandafter\providecommand%
  \csname scr@tso@#1@linefill\endcsname{%
    \if@sectionentrywithdots
      \TOCLineLeaderFill\relax
    \else
      \hfill
    \fi
  }%
  % Für die Einträge die Schrift von Element sectionentry verwenden.
  \expandafter\providecommand%
  \csname scr@tso@#1@entryformat\endcsname{\usekomafont{sectionentry}}%
  \expandafter\providecommand%
  \csname scr@tso@#1@pagenumberformat\endcsname[1]{\usekomafont{sectionentry}{\usekomafont{sectionentrypagenumber}{##1}}}%
  \expandafter\providecommand\expandafter*%
  \csname scr@tso@#1@beforeskip\endcsname{1.0em \@plus\p@}%
}
%</article>
%</section>
%    \end{macrocode}
% \end{macro}^^A \scr@dte@def@l@section
%
% \begin{macro}{\scr@dte@def@l@subsection}
%   \changes{v3.20}{2015/12/07}{neuer Verzeichnisstil \texttt{subsection}}^^A
% Dieser Stil existiert nur bei \textsf{scrartcl} und entspricht dann dem Stil
% \texttt{section} bei \textsf{scrbook} und \textsf{scrreprt}.
%    \begin{macrocode}
%<*subsection&article>
%%%            (run: class,style,subsection)
\CloneTOCEntryStyle{tocline}{subsection}
\TOCEntryStyleStartInitCode{subsection}{%
  \expandafter\providecommand%
  \csname scr@tso@#1@linefill\endcsname{\TOCLineLeaderFill\relax}%
}
%</subsection&article>
%    \end{macrocode}
% \end{macro}^^A \scr@dte@def@l@subsection
%
% \begin{macro}{\scr@dte@def@l@default}
%   \changes{v3.20}{2015/12/07}{neuer Verzeichnisstil \texttt{default}}^^A
% Dieser Stil entspricht bei \textsf{scrbook} und \textsf{scrreprt} dem Stil
% \texttt{section} und bei \textsf{scrartcl} dem Stil \textsf{subsection}.
%    \begin{macrocode}
%<*default>
%%%            (run: class,style,default)
%<book|report>\CloneTOCEntryStyle{section}{default}
%<article>\CloneTOCEntryStyle{subsection}{default}
%</default>
%    \end{macrocode}
% \end{macro}
%
% \iffalse
%</style>
%</class>
% \fi
%
% \Finale
%
\endinput
%
% end of file `scrkernel-tocstyle.dtx'
%%% Local Variables:
%%% mode: doctex
%%% coding: iso-latin-1
%%% TeX-master: t
%%% End:
